diff a/frameworks/native/rdb/src/rdb_store_impl.cpp b/frameworks/native/rdb/src/rdb_store_impl.cpp	(rejected hunks)
@@ -42,6 +42,7 @@
 #include "sqlite_statement.h"
 #include "sqlite_utils.h"
 #include "step_result_set.h"
+#include "values_buckets.h"
 #include "task_executor.h"
 #include "traits.h"
 
@@ -353,16 +354,24 @@ int RdbStoreImpl::Insert(int64_t &outRowId, const std::string &table, const Valu
 int RdbStoreImpl::BatchInsert(int64_t &outInsertNum, const std::string &table, const std::vector<ValuesBucket> &values)
 {
     SqlStatistic sqlStatistic("", SqlStatistic::Step::STEP_TOTAL);
-    return BatchInsertEntry(outInsertNum, table, values);
+    return BatchInsertEntry(table, values, values.size(), outInsertNum);
 }
 
-int RdbStoreImpl::BatchInsertEntry(int64_t &outInsertNum, const std::string &table,
-    const std::vector<ValuesBucket> &values)
+std::pair<int, int64_t> RdbStoreImpl::BatchInsert(const std::string &table, const ValuesBuckets &values)
+{
+    SqlStatistic sqlStatistic("", SqlStatistic::Step::STEP_TOTAL);
+    int64_t rowSize = 0;
+    auto ret = BatchInsertEntry(table, values, values.RowSize(), rowSize);
+    return { ret, rowSize };
+}
+
+template<typename T>
+int RdbStoreImpl::BatchInsertEntry(const std::string &table, const T &values, size_t rowSize, int64_t &outInsertNum)
 {
     if (isReadOnly_ || (config_.GetDBType() == DB_VECTOR)) {
         return E_NOT_SUPPORT;
     }
-    if (values.empty()) {
+    if (rowSize == 0) {
         outInsertNum = 0;
         return E_OK;
     }
@@ -373,7 +382,7 @@ int RdbStoreImpl::BatchInsertEntry(int64_t &outInsertNum, const std::string &tab
     auto executeSqlArgs = GenerateSql(table, values, connection->GetMaxVariable());
     if (executeSqlArgs.empty()) {
         LOG_ERROR("empty, table=%{public}s, values:%{public}zu, max number:%{public}d.", table.c_str(),
-            values.size(), connection->GetMaxVariable());
+                  rowSize, connection->GetMaxVariable());
         return E_INVALID_ARGS;
     }
 #if !defined(WINDOWS_PLATFORM) && !defined(MAC_PLATFORM) && !defined(ANDROID_PLATFORM) && !defined(IOS_PLATFORM)
@@ -395,7 +404,7 @@ int RdbStoreImpl::BatchInsertEntry(int64_t &outInsertNum, const std::string &tab
         }
     }
     connection = nullptr;
-    outInsertNum = static_cast<int64_t>(values.size());
+    outInsertNum = static_cast<int64_t>(rowSize);
     DoCloudSync(table);
     return E_OK;
 }
@@ -441,7 +450,37 @@ RdbStoreImpl::ExecuteSqls RdbStoreImpl::GenerateSql(const std::string& table, co
     }
     sql.pop_back();
     sql.append(") VALUES ");
-    return SqliteSqlBuilder::MakeExecuteSqls(sql, std::move(args), fields.size(), limit);
+    return SqliteSqlBuilder::MakeExecuteSqls(sql, args, fields.size(), limit);
+}
+
+RdbStoreImpl::ExecuteSqlsRef RdbStoreImpl::GenerateSql(
+    const std::string& table, const ValuesBuckets& buckets, int limit)
+{
+    auto [fields, values] = buckets.GetFieldsAndValues();
+    auto columnSize = fields->size();
+    auto rowSize = buckets.RowSize();
+    LOG_INFO("columnSize=%{public}zu, rowSize=%{public}zu", columnSize, rowSize);
+
+    ValueObject object;
+    std::reference_wrapper<ValueObject> emptyRef(object);
+    std::vector<std::reference_wrapper<ValueObject>> args(columnSize * rowSize, emptyRef);
+    std::string sql = "INSERT OR REPLACE INTO " + table + " (";
+    size_t columnIndex = 0;
+    for (auto &field : *fields) {
+        for (size_t row = 0; row < rowSize; ++row) {
+            auto [errorCode, value] = buckets.Get(row, std::ref(field));
+            if (errorCode != E_OK) {
+                LOG_ERROR("not found %{public}s in row=%{public}zu", field.c_str(), row);
+                return ExecuteSqlsRef();
+            }
+            args[columnIndex + row * columnSize] = value;
+        }
+        columnIndex++;
+        sql.append(field).append(",");
+    }
+    sql.pop_back();
+    sql.append(") VALUES ");
+    return SqliteSqlBuilder::MakeExecuteSqls(sql, args, columnSize, limit);
 }
 
 int RdbStoreImpl::Replace(int64_t &outRowId, const std::string &table, const ValuesBucket &values)
@@ -1748,7 +1787,7 @@ int RdbStoreImpl::GetDestPath(const std::string &backupPath, std::string &destPa
             return E_ERROR;
         }
     }
- 
+
     if (access(destPath.c_str(), F_OK) != E_OK) {
         LOG_ERROR("The backupFilePath does not exists.");
         return E_INVALID_FILE_PATH;
