diff --git a/test/ndk/BUILD.gn b/test/ndk/BUILD.gn
index fb08020..9df1f38 100644
--- a/test/ndk/BUILD.gn
+++ b/test/ndk/BUILD.gn
@@ -83,5 +83,8 @@ group("fuzztest") {
     "fuzztest/valuebucket_fuzzer:fuzztest",
     "fuzztest/valueobject_fuzzer:fuzztest",
     "fuzztest/ohpredicates_fuzzer:fuzztest",
+    "fuzztest/oh_data_values_fuzzer:fuzztest",
+    "fuzztest/oh_predicates_fuzzer:fuzztest",
+    "fuzztest/oh_rdb_crypto_param_fuzzer:fuzztest",
   ]
 }
diff --git a/test/ndk/fuzztest/oh_data_values_fuzzer/BUILD.gn b/test/ndk/fuzztest/oh_data_values_fuzzer/BUILD.gn
new file mode 100644
index 0000000..0bd598f
--- /dev/null
+++ b/test/ndk/fuzztest/oh_data_values_fuzzer/BUILD.gn
@@ -0,0 +1,69 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#####################hydra-fuzz###################
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("//foundation/distributeddatamgr/relational_store/relational_store.gni")
+
+##############################fuzztest##########################################
+ohos_fuzztest("oh_data_values_fuzzer") {
+  module_out_path = "relational_store/relational_store"
+
+  include_dirs = [
+    "${relational_store_base_path}/interfaces/ndk/include",
+    "${relational_store_innerapi_path}/rdb/include",
+    "${relational_store_innerapi_path}/appdatafwk/include",
+    "${relational_store_base_path}/interfaces/ndk/src",
+    "${relational_store_common_path}/include",
+    "${relational_store_native_path}/rdb/include",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+  ]
+
+  fuzz_config_file = "${relational_store_base_path}/test/ndk/fuzztest/oh_data_values_fuzzer"
+
+  sources = [ "oh_data_values_fuzzer.cpp" ]
+
+  deps = [
+    "${relational_store_base_path}/interfaces/ndk:native_rdb_ndk",
+    "${relational_store_innerapi_path}/rdb:native_rdb",
+  ]
+
+  external_deps = [
+    "ability_base:zuri",
+    "ability_runtime:dataobs_manager",
+    "c_utils:utils",
+    "hilog:libhilog",
+    "ipc:ipc_core",
+    "kv_store:distributeddb",
+    "kv_store:distributeddb_client",
+    "sqlite:sqlite",
+  ]
+}
+
+###############################################################################
+group("fuzztest") {
+  testonly = true
+  deps = []
+  deps += [
+    # deps file
+    ":oh_data_values_fuzzer",
+  ]
+}
+###############################################################################
diff --git a/test/ndk/fuzztest/oh_data_values_fuzzer/corpus/init b/test/ndk/fuzztest/oh_data_values_fuzzer/corpus/init
new file mode 100644
index 0000000..65af8ee
--- /dev/null
+++ b/test/ndk/fuzztest/oh_data_values_fuzzer/corpus/init
@@ -0,0 +1,14 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+FUZZ
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.cpp b/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.cpp
new file mode 100644
index 0000000..17b2b03
--- /dev/null
+++ b/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.cpp
@@ -0,0 +1,473 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "oh_data_values_fuzzer.h"
+
+#include <fuzzer/FuzzedDataProvider.h>
+
+#include "oh_data_values.h"
+#include "grd_api_manager.h"
+#include "oh_data_value.h"
+#include "oh_data_values_buckets.h"
+#include "oh_value_object.h"
+#include "rdb_errno.h"
+#include "relational_store.h"
+#include "relational_store_error_code.h"
+#include "relational_store_impl.h"
+
+#define MAX_STRING_LENGTH 100
+#define MAX_COUNT 100
+
+using namespace OHOS;
+using namespace OHOS::NativeRdb;
+using namespace OHOS::RdbNdk;
+
+namespace OHOS {
+
+OH_Data_Values *CreateRandomDataValues(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return nullptr;
+    }
+
+    const int loopsMin = 0;
+    const int loopsMax = 100;
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(loopsMin, loopsMax);
+    for (size_t i = 0; i < loops; ++i) {
+        int64_t intValue = provider.ConsumeIntegral<int64_t>();
+        double realValue = provider.ConsumeFloatingPoint<double>();
+        std::string textValue = provider.ConsumeRandomLengthString();
+        size_t blobLength = provider.ConsumeIntegral<size_t>();
+        std::vector<uint8_t> blobValue = provider.ConsumeBytes<uint8_t>(blobLength);
+
+        OH_Values_PutInt(values, intValue);
+        OH_Values_PutReal(values, realValue);
+        OH_Values_PutText(values, textValue.c_str());
+        OH_Values_PutBlob(values, blobValue.data(), blobValue.size());
+    }
+
+    return values;
+}
+
+void OH_Values_PutFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    OH_Data_Value *dataValue = OH_Value_Create();
+    if (dataValue != nullptr) {
+        OH_Values_Put(values, dataValue);
+    }
+
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutNullFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    OH_Values_PutNull(values);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutIntFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    int64_t intValue = provider.ConsumeIntegral<int64_t>();
+    OH_Values_PutInt(values, intValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutRealFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    double realValue = provider.ConsumeFloatingPoint<double>();
+    OH_Values_PutReal(values, realValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutTextFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    std::string textValue = provider.ConsumeRandomLengthString();
+    OH_Values_PutText(values, textValue.c_str());
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutBlobFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    size_t blobLength = provider.ConsumeIntegral<size_t>();
+    std::vector<uint8_t> blobValue = provider.ConsumeBytes<uint8_t>(blobLength);
+    OH_Values_PutBlob(values, blobValue.data(), blobValue.size());
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutAssetFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    Data_Asset *asset = OH_Data_Asset_CreateOne();
+    if (asset == nullptr) {
+        return;
+    }
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutAssetsFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    const int loopsMin = 0;
+    const int loopsMax = 100;
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(loopsMin, loopsMax);
+    std::vector<Data_Asset *> assets;
+    for (size_t i = 0; i < loops; ++i) {
+        Data_Asset *asset = OH_Data_Asset_CreateOne();
+        if (asset == nullptr) {
+            return;
+        }
+        assets.push_back(asset);
+    }
+
+    if (!assets.empty()) {
+        OH_Values_PutAssets(values, assets.data(), assets.size());
+    }
+
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutFloatVectorFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    const int loopsMin = 0;
+    const int loopsMax = 100;
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(loopsMin, loopsMax);
+    std::vector<float> floatVector(loops);
+    for (size_t i = 0; i < loops; ++i) {
+        floatVector[i] = provider.ConsumeFloatingPoint<float>();
+    }
+
+    OH_Values_PutFloatVector(values, floatVector.data(), floatVector.size());
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_PutUnlimitedIntFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = OH_Values_Create();
+    if (values == nullptr) {
+        return;
+    }
+
+    int sign = provider.ConsumeIntegral<int>();
+    const int loopsMin = 0;
+    const int loopsMax = 100;
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(loopsMin, loopsMax);
+    std::vector<uint64_t> trueForm(loops);
+    for (size_t i = 0; i < loops; ++i) {
+        trueForm[i] = provider.ConsumeIntegral<uint64_t>();
+    }
+
+    OH_Values_PutUnlimitedInt(values, sign, trueForm.data(), trueForm.size());
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_CountFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    size_t count;
+    OH_Values_Count(values, &count);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetTypeFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    OH_ColumnType type;
+    OH_Values_GetType(values, index, &type);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    OH_Data_Value *dataValue;
+    OH_Values_Get(values, index, &dataValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_IsNullFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    bool isNull;
+    OH_Values_IsNull(values, index, &isNull);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetIntFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    int64_t intValue;
+    OH_Values_GetInt(values, index, &intValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetRealFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    double realValue;
+    OH_Values_GetReal(values, index, &realValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetTextFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    const char *textValue;
+    OH_Values_GetText(values, index, &textValue);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetBlobFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    const uint8_t *blobValue;
+    size_t blobLength;
+    OH_Values_GetBlob(values, index, &blobValue, &blobLength);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetAssetFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    Data_Asset *asset = OH_Data_Asset_CreateOne();
+    if (asset != nullptr) {
+        OH_Values_GetAsset(values, index, asset);
+    }
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetAssetsCountFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t count;
+    OH_Values_GetAssetsCount(values, index, &count);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetAssetsFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t inLen;
+    OH_Values_GetAssetsCount(values, index, &inLen);
+    if (inLen > 0) {
+        Data_Asset *asset = OH_Data_Asset_CreateOne();
+        if (asset == nullptr) {
+            return;
+        }
+        size_t outLen;
+        OH_Values_GetAssets(values, index, &asset, inLen, &outLen);
+    }
+
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetFloatVectorCountFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t count;
+    OH_Values_GetFloatVectorCount(values, index, &count);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetFloatVectorFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t inLen;
+    OH_Values_GetFloatVectorCount(values, index, &inLen);
+    if (inLen > 0) {
+        float *floatVector = new float[inLen];
+        size_t outLen;
+        OH_Values_GetFloatVector(values, index, floatVector, inLen, &outLen);
+        delete[] floatVector;
+    }
+
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetUnlimitedIntBandFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t count;
+    OH_Values_GetUnlimitedIntBand(values, index, &count);
+    OH_Values_Destroy(values);
+}
+
+void OH_Values_GetUnlimitedIntFuzz(FuzzedDataProvider &provider)
+{
+    OH_Data_Values *values = CreateRandomDataValues(provider);
+    if (values == nullptr) {
+        return;
+    }
+
+    int index = provider.ConsumeIntegral<int>();
+    size_t inLen;
+    OH_Values_GetUnlimitedIntBand(values, index, &inLen);
+    if (inLen > 0) {
+        int sign;
+        uint64_t *trueForm = new uint64_t[inLen];
+        size_t outLen;
+        OH_Values_GetUnlimitedInt(values, index, &sign, trueForm, inLen, &outLen);
+        delete[] trueForm;
+    }
+
+    OH_Values_Destroy(values);
+}
+
+} // namespace OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
+{
+    // Run your code on data
+    FuzzedDataProvider provider(data, size);
+    OHOS::OH_Values_PutFuzz(provider);
+    OHOS::OH_Values_PutNullFuzz(provider);
+    OHOS::OH_Values_PutIntFuzz(provider);
+    OHOS::OH_Values_PutRealFuzz(provider);
+    OHOS::OH_Values_PutTextFuzz(provider);
+    OHOS::OH_Values_PutBlobFuzz(provider);
+    OHOS::OH_Values_PutAssetFuzz(provider);
+    OHOS::OH_Values_PutAssetsFuzz(provider);
+    OHOS::OH_Values_PutFloatVectorFuzz(provider);
+    OHOS::OH_Values_PutUnlimitedIntFuzz(provider);
+    OHOS::OH_Values_CountFuzz(provider);
+    OHOS::OH_Values_GetTypeFuzz(provider);
+    OHOS::OH_Values_GetFuzz(provider);
+    OHOS::OH_Values_IsNullFuzz(provider);
+    OHOS::OH_Values_GetIntFuzz(provider);
+    OHOS::OH_Values_GetRealFuzz(provider);
+    OHOS::OH_Values_GetTextFuzz(provider);
+    OHOS::OH_Values_GetBlobFuzz(provider);
+    OHOS::OH_Values_GetAssetFuzz(provider);
+    OHOS::OH_Values_GetAssetsCountFuzz(provider);
+    OHOS::OH_Values_GetAssetsFuzz(provider);
+    OHOS::OH_Values_GetFloatVectorCountFuzz(provider);
+    OHOS::OH_Values_GetFloatVectorFuzz(provider);
+    OHOS::OH_Values_GetUnlimitedIntBandFuzz(provider);
+    OHOS::OH_Values_GetUnlimitedIntFuzz(provider);
+    return 0;
+}
diff --git a/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.h b/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.h
new file mode 100644
index 0000000..4aba282
--- /dev/null
+++ b/test/ndk/fuzztest/oh_data_values_fuzzer/oh_data_values_fuzzer.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OH_DATA_VALUES_FUZZER_H
+#define OH_DATA_VALUES_FUZZER_H
+
+#define FUZZ_PROJECT_NAME "oh_data_values_fuzzer"
+
+#endif // OH_DATA_VALUES_FUZZER_H
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_data_values_fuzzer/project.xml b/test/ndk/fuzztest/oh_data_values_fuzzer/project.xml
new file mode 100644
index 0000000..66e1dca
--- /dev/null
+++ b/test/ndk/fuzztest/oh_data_values_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2025 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/ndk/fuzztest/oh_predicates_fuzzer/BUILD.gn b/test/ndk/fuzztest/oh_predicates_fuzzer/BUILD.gn
new file mode 100644
index 0000000..d39cf55
--- /dev/null
+++ b/test/ndk/fuzztest/oh_predicates_fuzzer/BUILD.gn
@@ -0,0 +1,69 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#####################hydra-fuzz###################
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("//foundation/distributeddatamgr/relational_store/relational_store.gni")
+
+##############################fuzztest##########################################
+ohos_fuzztest("oh_predicates_fuzzer") {
+  module_out_path = "relational_store/relational_store"
+
+  include_dirs = [
+    "${relational_store_base_path}/interfaces/ndk/include",
+    "${relational_store_innerapi_path}/rdb/include",
+    "${relational_store_innerapi_path}/appdatafwk/include",
+    "${relational_store_base_path}/interfaces/ndk/src",
+    "${relational_store_common_path}/include",
+    "${relational_store_native_path}/rdb/include",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+  ]
+
+  fuzz_config_file = "${relational_store_base_path}/test/ndk/fuzztest/oh_predicates_fuzzer"
+
+  sources = [ "oh_predicates_fuzzer.cpp" ]
+
+  deps = [
+    "${relational_store_base_path}/interfaces/ndk:native_rdb_ndk",
+    "${relational_store_innerapi_path}/rdb:native_rdb",
+  ]
+
+  external_deps = [
+    "ability_base:zuri",
+    "ability_runtime:dataobs_manager",
+    "c_utils:utils",
+    "hilog:libhilog",
+    "ipc:ipc_core",
+    "kv_store:distributeddb",
+    "kv_store:distributeddb_client",
+    "sqlite:sqlite",
+  ]
+}
+
+###############################################################################
+group("fuzztest") {
+  testonly = true
+  deps = []
+  deps += [
+    # deps file
+    ":oh_predicates_fuzzer",
+  ]
+}
+###############################################################################
diff --git a/test/ndk/fuzztest/oh_predicates_fuzzer/corpus/init b/test/ndk/fuzztest/oh_predicates_fuzzer/corpus/init
new file mode 100644
index 0000000..65af8ee
--- /dev/null
+++ b/test/ndk/fuzztest/oh_predicates_fuzzer/corpus/init
@@ -0,0 +1,14 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+FUZZ
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.cpp b/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.cpp
new file mode 100644
index 0000000..c6c4295
--- /dev/null
+++ b/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.cpp
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "oh_predicates_fuzzer.h"
+
+#include <fuzzer/FuzzedDataProvider.h>
+
+#include "grd_api_manager.h"
+#include "oh_data_value.h"
+#include "oh_data_values.h"
+#include "oh_data_values_buckets.h"
+#include "oh_predicates.h"
+#include "oh_value_object.h"
+#include "rdb_errno.h"
+#include "relational_store.h"
+#include "relational_store_error_code.h"
+#include "relational_store_impl.h"
+
+using namespace OHOS;
+using namespace OHOS::NativeRdb;
+using namespace OHOS::RdbNdk;
+
+#define LENGTH_MIN 1
+#define LENGTH_MAX 10
+
+#define STRING_LENGTH_MAX 20
+
+namespace OHOS {
+
+std::vector<OH_VObject *> ConsumeRandomLengthValueObjectVector(FuzzedDataProvider &provider)
+{
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(LENGTH_MIN, LENGTH_MAX);
+    std::vector<OH_VObject *> columns;
+    for (size_t i = 0; i < loops; ++i) {
+        OH_VObject *obj = OH_Rdb_CreateValueObject();
+        columns.emplace_back(obj);
+    }
+    return columns;
+}
+
+void TestOH_Predicates_equalTo(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->equalTo(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_notEqualTo(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->notEqualTo(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_beginWrap(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    predicates->beginWrap(predicates);
+}
+
+void TestOH_Predicates_endWrap(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    predicates->endWrap(predicates);
+}
+
+void TestOH_Predicates_orOperate(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    predicates->orOperate(predicates);
+}
+
+void TestOH_Predicates_andOperate(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    predicates->andOperate(predicates);
+}
+
+void TestOH_Predicates_isNull(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->isNull(predicates, field.c_str());
+}
+
+void TestOH_Predicates_isNotNull(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->isNotNull(predicates, field.c_str());
+}
+
+void TestOH_Predicates_like(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->like(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_between(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->between(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_notBetween(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->notBetween(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_greaterThan(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->greaterThan(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_lessThan(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->lessThan(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_greaterThanOrEqualTo(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->greaterThanOrEqualTo(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_lessThanOrEqualTo(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    predicates->lessThanOrEqualTo(predicates, field.c_str(), obj);
+}
+
+void TestOH_Predicates_orderBy(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    OH_VObject *obj = OH_Rdb_CreateValueObject();
+    if (obj == nullptr) {
+        return;
+    }
+    std::string value = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    obj->putText(obj, value.c_str());
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_OrderType type = static_cast<OH_OrderType>(provider.ConsumeIntegral<int>());
+    predicates->orderBy(predicates, field.c_str(), type);
+}
+
+void TestOH_Predicates_distinct(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    predicates->distinct(predicates);
+}
+
+void TestOH_Predicates_limit(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    unsigned int value = provider.ConsumeIntegral<unsigned int>();
+    predicates->limit(predicates, value);
+}
+
+void TestOH_Predicates_offset(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    unsigned int rowOffset = provider.ConsumeIntegral<unsigned int>();
+    predicates->offset(predicates, rowOffset);
+}
+
+void TestOH_Predicates_groupBy(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    size_t loops = provider.ConsumeIntegralInRange<size_t>(LENGTH_MIN, LENGTH_MAX);
+    const char *fields[loops];
+    for (size_t i = 0; i < loops; ++i) {
+        static std::string fieldsString = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX).c_str();
+        fields[i] = fieldsString.c_str();
+    }
+    predicates->groupBy(predicates, fields, loops);
+}
+
+void TestOH_Predicates_in(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    std::vector<OH_VObject *> values = ConsumeRandomLengthValueObjectVector(provider);
+    for (auto value : values) {
+        predicates->in(predicates, field.c_str(), value);
+    }
+}
+
+void TestOH_Predicates_notIn(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    std::vector<OH_VObject *> values = ConsumeRandomLengthValueObjectVector(provider);
+    for (auto value : values) {
+        predicates->notIn(predicates, field.c_str(), value);
+    }
+}
+
+void TestOH_Predicates_Having(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string conditions = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Data_Values *values = OH_Values_Create();
+    OH_Predicates_Having(predicates, conditions.c_str(), values);
+}
+
+void TestOH_Predicates_NotLike(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    std::string pattern = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates_NotLike(predicates, field.c_str(), pattern.c_str());
+}
+
+void TestOH_Predicates_Glob(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    std::string pattern = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates_Glob(predicates, field.c_str(), pattern.c_str());
+}
+
+void TestOH_Predicates_NotGlob(FuzzedDataProvider &provider)
+{
+    std::string table = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates *predicates = OH_Rdb_CreatePredicates(table.c_str());
+    if (predicates == nullptr) {
+        return;
+    }
+    std::string field = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    std::string pattern = provider.ConsumeRandomLengthString(STRING_LENGTH_MAX);
+    OH_Predicates_NotGlob(predicates, field.c_str(), pattern.c_str());
+}
+} // namespace OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
+{
+    // Run your code on data
+    FuzzedDataProvider provider(data, size);
+    OHOS::TestOH_Predicates_equalTo(provider);
+    OHOS::TestOH_Predicates_notEqualTo(provider);
+    OHOS::TestOH_Predicates_beginWrap(provider);
+    OHOS::TestOH_Predicates_endWrap(provider);
+    OHOS::TestOH_Predicates_orOperate(provider);
+    OHOS::TestOH_Predicates_andOperate(provider);
+    OHOS::TestOH_Predicates_isNull(provider);
+    OHOS::TestOH_Predicates_isNotNull(provider);
+    OHOS::TestOH_Predicates_like(provider);
+    OHOS::TestOH_Predicates_between(provider);
+    OHOS::TestOH_Predicates_notBetween(provider);
+    OHOS::TestOH_Predicates_greaterThan(provider);
+    OHOS::TestOH_Predicates_lessThan(provider);
+    OHOS::TestOH_Predicates_greaterThanOrEqualTo(provider);
+    OHOS::TestOH_Predicates_lessThanOrEqualTo(provider);
+    OHOS::TestOH_Predicates_orderBy(provider);
+    OHOS::TestOH_Predicates_distinct(provider);
+    OHOS::TestOH_Predicates_limit(provider);
+    OHOS::TestOH_Predicates_offset(provider);
+    OHOS::TestOH_Predicates_groupBy(provider);
+    OHOS::TestOH_Predicates_in(provider);
+    OHOS::TestOH_Predicates_notIn(provider);
+    OHOS::TestOH_Predicates_Having(provider);
+    OHOS::TestOH_Predicates_NotLike(provider);
+    OHOS::TestOH_Predicates_Glob(provider);
+    OHOS::TestOH_Predicates_NotGlob(provider);
+    return 0;
+}
diff --git a/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.h b/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.h
new file mode 100644
index 0000000..2534c69
--- /dev/null
+++ b/test/ndk/fuzztest/oh_predicates_fuzzer/oh_predicates_fuzzer.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OH_PREDICATES_FUZZER_H
+#define OH_PREDICATES_FUZZER_H
+
+#define FUZZ_PROJECT_NAME "oh_predicates_fuzzer"
+
+#endif // OH_PREDICATES_FUZZER_H
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_predicates_fuzzer/project.xml b/test/ndk/fuzztest/oh_predicates_fuzzer/project.xml
new file mode 100644
index 0000000..66e1dca
--- /dev/null
+++ b/test/ndk/fuzztest/oh_predicates_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2025 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/BUILD.gn b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/BUILD.gn
new file mode 100644
index 0000000..3cb6405
--- /dev/null
+++ b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/BUILD.gn
@@ -0,0 +1,69 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#####################hydra-fuzz###################
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("//foundation/distributeddatamgr/relational_store/relational_store.gni")
+
+##############################fuzztest##########################################
+ohos_fuzztest("oh_rdb_crypto_param_fuzzer") {
+  module_out_path = "relational_store/relational_store"
+
+  include_dirs = [
+    "${relational_store_base_path}/interfaces/ndk/include",
+    "${relational_store_innerapi_path}/rdb/include",
+    "${relational_store_innerapi_path}/appdatafwk/include",
+    "${relational_store_base_path}/interfaces/ndk/src",
+    "${relational_store_common_path}/include",
+    "${relational_store_native_path}/rdb/include",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+  ]
+
+  fuzz_config_file = "${relational_store_base_path}/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer"
+
+  sources = [ "oh_rdb_crypto_param_fuzzer.cpp" ]
+
+  deps = [
+    "${relational_store_base_path}/interfaces/ndk:native_rdb_ndk",
+    "${relational_store_innerapi_path}/rdb:native_rdb",
+  ]
+
+  external_deps = [
+    "ability_base:zuri",
+    "ability_runtime:dataobs_manager",
+    "c_utils:utils",
+    "hilog:libhilog",
+    "ipc:ipc_core",
+    "kv_store:distributeddb",
+    "kv_store:distributeddb_client",
+    "sqlite:sqlite",
+  ]
+}
+
+###############################################################################
+group("fuzztest") {
+  testonly = true
+  deps = []
+  deps += [
+    # deps file
+    ":oh_rdb_crypto_param_fuzzer",
+  ]
+}
+###############################################################################
diff --git a/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/corpus/init b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/corpus/init
new file mode 100644
index 0000000..65af8ee
--- /dev/null
+++ b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/corpus/init
@@ -0,0 +1,14 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+FUZZ
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.cpp b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.cpp
new file mode 100644
index 0000000..e9ec61c
--- /dev/null
+++ b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "oh_rdb_crypto_param_fuzzer.h"
+
+#include <fuzzer/FuzzedDataProvider.h>
+
+#include "grd_api_manager.h"
+#include "oh_data_value.h"
+#include "oh_data_values.h"
+#include "oh_data_values_buckets.h"
+#include "oh_predicates.h"
+#include "oh_rdb_crypto_param.h"
+#include "oh_value_object.h"
+#include "rdb_errno.h"
+#include "relational_store.h"
+#include "relational_store_error_code.h"
+#include "relational_store_impl.h"
+
+#define LENGTH_MIN 1
+#define LENGTH_MAX 10
+
+using namespace OHOS;
+using namespace OHOS::NativeRdb;
+using namespace OHOS::RdbNdk;
+using namespace std;
+
+namespace OHOS {
+
+void OH_Rdb_DestroyCryptoParamFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        OH_Rdb_DestroyCryptoParam(param);
+    }
+}
+
+void OH_Crypto_SetEncryptionKeyFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        size_t bytesSize = provider.ConsumeIntegralInRange<size_t>(LENGTH_MIN, LENGTH_MAX);
+        std::vector<uint8_t> blobData = provider.ConsumeBytes<uint8_t>(bytesSize);
+        OH_Crypto_SetEncryptionKey(param, blobData.data(), blobData.size());
+    }
+}
+
+void OH_Crypto_SetIterationFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        const int64_t iteration = provider.ConsumeIntegral<int64_t>();
+        OH_Crypto_SetIteration(param, iteration);
+    }
+}
+
+void OH_Crypto_SetEncryptionAlgoFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        const int32_t algo = provider.ConsumeIntegral<int32_t>();
+        OH_Crypto_SetEncryptionAlgo(param, algo);
+    }
+}
+
+void OH_Crypto_SetHmacAlgoFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        const int32_t algo = provider.ConsumeIntegral<int32_t>();
+        OH_Crypto_SetHmacAlgo(param, algo);
+    }
+}
+
+void OH_Crypto_SetKdfAlgoFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        const int32_t algo = provider.ConsumeIntegral<int32_t>();
+        OH_Crypto_SetKdfAlgo(param, algo);
+    }
+}
+
+void OH_Crypto_SetCryptoPageSizeFuzz(FuzzedDataProvider &provider)
+{
+    OH_Rdb_CryptoParam *param = OH_Rdb_CreateCryptoParam();
+    if (param != nullptr) {
+        const int64_t size = provider.ConsumeIntegral<int64_t>();
+        OH_Crypto_SetCryptoPageSize(param, size);
+    }
+}
+} // namespace OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
+{
+    FuzzedDataProvider provider(data, size);
+    OHOS::OH_Rdb_DestroyCryptoParamFuzz(provider);
+    OHOS::OH_Crypto_SetEncryptionKeyFuzz(provider);
+    OHOS::OH_Crypto_SetIterationFuzz(provider);
+    OHOS::OH_Crypto_SetEncryptionAlgoFuzz(provider);
+    OHOS::OH_Crypto_SetHmacAlgoFuzz(provider);
+    OHOS::OH_Crypto_SetKdfAlgoFuzz(provider);
+    OHOS::OH_Crypto_SetCryptoPageSizeFuzz(provider);
+    return 0;
+}
diff --git a/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.h b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.h
new file mode 100644
index 0000000..3e3da2e
--- /dev/null
+++ b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/oh_rdb_crypto_param_fuzzer.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OH_RDB_CRYPTO_PARAM_FUZZER_H
+#define OH_RDB_CRYPTO_PARAM_FUZZER_H
+
+#define FUZZ_PROJECT_NAME "oh_rdb_crypto_param_fuzzer"
+
+#endif // OH_RDB_CRYPTO_PARAM_FUZZER_H
\ No newline at end of file
diff --git a/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/project.xml b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/project.xml
new file mode 100644
index 0000000..66e1dca
--- /dev/null
+++ b/test/ndk/fuzztest/oh_rdb_crypto_param_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2025 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
