diff --git a/bundle.json b/bundle.json
index 1b8434eba05671d213625083ed40d7ccddc8a806..64dbfa4569356d7b300645525267863f9a815354 100644
--- a/bundle.json
+++ b/bundle.json
@@ -67,10 +67,11 @@
                 "icu",
                 "sqlite",
                 "file_api",
-                "json"
+                "cJSON"
             ],
             "third_party": [
-                "sqlite"
+                "sqlite",
+                "cJSON"
             ]
         },
         "build": {
diff --git a/frameworks/js/napi/graphstore/BUILD.gn b/frameworks/js/napi/graphstore/BUILD.gn
index e970ce11fb95b2d30b2beb91e7d6ee1378167075..4ee72285929b3e9f3d58ece261733b022dce676b 100644
--- a/frameworks/js/napi/graphstore/BUILD.gn
+++ b/frameworks/js/napi/graphstore/BUILD.gn
@@ -44,11 +44,15 @@ ohos_shared_library("graphstore") {
     "${relational_store_frameworks_path}/js/napi/graphstore/src/napi_gdb_store_helper.cpp",
     "${relational_store_frameworks_path}/js/napi/graphstore/src/napi_gdb_transaction.cpp",
   ]
-  deps = [ "${relational_store_innerapi_path}/gdb:native_graphstore" ]
+  deps = [
+    "${relational_store_innerapi_path}/gdb:native_graphstore",
+    "${relational_store_innerapi_path}/appdatafwk:relational_common_base",
+  ]
   external_deps = [
     "ability_runtime:abilitykit_native",
     "ability_runtime:extensionkit_native",
     "ability_runtime:napi_base_context",
+    "cJSON:cjson",
     "c_utils:utils",
     "eventhandler:libeventhandler",
     "hilog:libhilog",
diff --git a/frameworks/native/appdatafwk/src/serializable.cpp b/frameworks/native/appdatafwk/src/serializable.cpp
index 2a90ec7d9604d037ee8f5571c82102a630efc156..635dd2bfa963456c54370bb8403481b7d7cf3bb4 100644
--- a/frameworks/native/appdatafwk/src/serializable.cpp
+++ b/frameworks/native/appdatafwk/src/serializable.cpp
@@ -12,9 +12,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+#define LOG_TAG "Serializable"
 #include "serializable.h"
+
+#include <cJSON.h>
+#include <cmath>
+#include "logger.h"
 namespace OHOS {
+using namespace OHOS::Rdb;
 Serializable::json Serializable::Marshall() const
 {
     json root;
@@ -24,14 +29,16 @@ Serializable::json Serializable::Marshall() const
 
 bool Serializable::Unmarshall(const std::string &jsonStr)
 {
-    json jsonObj = json::parse(jsonStr, nullptr, false);
+    json jsonObj = json::parse(jsonStr);
     if (jsonObj.is_discarded()) {
         // if the string size is less than 1, means the string is invalid.
         if (jsonStr.empty()) {
+            LOG_WARN("jsonStr is empty");
             return false;
         }
-        jsonObj = json::parse(jsonStr.substr(1), nullptr, false); // drop first char to adapt A's value;
+        jsonObj = json::parse(jsonStr.substr(1)); // drop first char to adapt A's value;
         if (jsonObj.is_discarded()) {
+            LOG_WARN("jsonStr is discarded");
             return false;
         }
     }
@@ -40,13 +47,13 @@ bool Serializable::Unmarshall(const std::string &jsonStr)
 
 Serializable::json Serializable::ToJson(const std::string &jsonStr)
 {
-    json jsonObj = json::parse(jsonStr, nullptr, false);
+    json jsonObj = json::parse(jsonStr);
     if (jsonObj.is_discarded()) {
         // if the string size is less than 1, means the string is invalid.
         if (jsonStr.empty()) {
             return {};
         }
-        jsonObj = json::parse(jsonStr.substr(1), nullptr, false); // drop first char to adapt A's value;
+        jsonObj = json::parse(jsonStr.substr(1)); // drop first char to adapt A's value;
         if (jsonObj.is_discarded()) {
             return {};
         }
@@ -57,7 +64,7 @@ Serializable::json Serializable::ToJson(const std::string &jsonStr)
 bool Serializable::IsJson(const std::string &jsonStr)
 {
     if (!json::accept(jsonStr)) {
-        return json::accept(jsonStr.begin() + 1, jsonStr.end());
+        return json::accept(jsonStr.substr(1));
     }
     return true;
 }
@@ -141,6 +148,18 @@ bool Serializable::GetValue(const json &node, const std::string &name, Serializa
     return value.Unmarshal(subNode);
 }
 
+bool Serializable::GetValue(const json &node, const std::string &name, std::shared_ptr<Serializable> value)
+{
+    if (value == nullptr) {
+        return false;
+    }
+    auto &subNode = GetSubNode(node, name);
+    if (subNode.is_null() || !subNode.is_object()) {
+        return false;
+    }
+    return value->Unmarshal(subNode);
+}
+
 bool Serializable::SetValue(json &node, const std::string &value)
 {
     node = value;
@@ -190,7 +209,7 @@ bool Serializable::SetValue(json &node, const Serializable &value)
 
 const Serializable::json &Serializable::GetSubNode(const json &node, const std::string &name)
 {
-    static const json jsonNull = json::value_t::null;
+    static const json jsonNull;
     if (node.is_discarded() || node.is_null()) {
         return jsonNull;
     }
@@ -205,4 +224,666 @@ const Serializable::json &Serializable::GetSubNode(const json &node, const std::
     }
     return *it;
 }
+
+Serializable::JSONWrapper::JSONWrapper() : root_(nullptr)
+{
+    json_ = cJSON_CreateNull();
+    needDel_ = true;
+}
+
+Serializable::JSONWrapper::JSONWrapper(cJSON *json, cJSON *root, const std::string &key)
+    : json_(json), root_(root), key_(key), needDel_(root == nullptr && json_ != nullptr)
+{
+}
+
+Serializable::JSONWrapper::JSONWrapper(const std::string &jsonStr) : root_(nullptr), needDel_(true)
+{
+    json_ = cJSON_Parse(jsonStr.c_str());
+}
+
+Serializable::JSONWrapper::JSONWrapper(JSONWrapper &&jsonWrapper)
+{
+    json_ = jsonWrapper.json_;
+    jsonWrapper.json_ = nullptr;
+    root_ = jsonWrapper.root_;
+    jsonWrapper.root_ = nullptr;
+    key_ = std::move(jsonWrapper.key_);
+    children_ = std::move(jsonWrapper.children_);
+    needDel_ = jsonWrapper.needDel_;
+}
+
+Serializable::JSONWrapper::operator std::string() const
+{
+    return dump();
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(JSONWrapper &&jsonWrapper)
+{
+    if (this == &jsonWrapper) {
+        return *this;
+    }
+    if (needDel_) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    json_ = std::move(jsonWrapper.json_);
+    jsonWrapper.json_ = nullptr;
+    root_ = jsonWrapper.root_;
+    jsonWrapper.root_ = nullptr;
+    key_ = std::move(jsonWrapper.key_);
+    children_ = std::move(jsonWrapper.children_);
+    needDel_ = jsonWrapper.needDel_;
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(Serializable::JSONWrapper::Type type)
+{
+    if (json_ != nullptr) {
+        LOG_ERROR("cannot use operator=");
+        return *this;
+    }
+    switch (type) {
+        case Type::ARRAY:
+            json_ = cJSON_CreateArray();
+            break;
+        case Type::OBJECT:
+            json_ = cJSON_CreateObject();
+            break;
+        default:
+            LOG_ERROR("unknown type, type: %{public}d", static_cast<int32_t>(type));
+    }
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(bool value)
+{
+    if (needDel_ && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        if (cJSON_IsBool(json_)) {
+            cJSON_SetBoolValue(json_, value);
+        } else {
+            LOG_WARN("type is not bool");
+        }
+        return *this;
+    }
+    json_ = cJSON_CreateBool(value);
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(int32_t value)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        if (cJSON_IsNumber(json_)) {
+            cJSON_SetNumberValue(json_, value);
+        } else {
+            LOG_WARN("type is not number");
+        }
+        return *this;
+    }
+    json_ = cJSON_CreateNumber(value);
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(uint32_t value)
+{
+    int32_t number = static_cast<int32_t>(value);
+    return operator=(number);
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(int64_t value)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        if (cJSON_IsNumber(json_)) {
+            cJSON_SetNumberValue(json_, value);
+        } else {
+            LOG_WARN("type is not number");
+        }
+        return *this;
+    }
+    json_ = cJSON_CreateNumber(value);
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(uint64_t value)
+{
+    int64_t number = static_cast<int64_t>(value);
+    return operator=(number);
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(double value)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        if (cJSON_IsNumber(json_)) {
+            cJSON_SetNumberValue(json_, value);
+        } else {
+            LOG_WARN("type is not number");
+        }
+        return *this;
+    }
+    json_ = cJSON_CreateNumber(value);
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(const char *value)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        return *this;
+    }
+    json_ = cJSON_CreateString(value);
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(const std::string &value)
+{
+    return operator=(value.c_str());
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator=(const std::vector<uint8_t> &value)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ != nullptr) {
+        return *this;
+    }
+    json_ = cJSON_CreateArray();
+    children_.clear();
+    for (size_t i = 0; json_ && (i < value.size()); i++) {
+        auto node = cJSON_CreateNumber(value[i]);
+        if (!node || !cJSON_AddItemToArray(json_, node)) {
+            cJSON_Delete(json_);
+            json_ = nullptr;
+            children_.clear();
+            return *this;
+        }
+        children_.push_back(std::make_shared<JSONWrapper>(node, json_));
+    }
+    if (json_ == nullptr || root_ == nullptr) {
+        return *this;
+    }
+    AddToRoot();
+    return *this;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator[](const std::string &key)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ == nullptr) {
+        json_ = cJSON_CreateObject();
+        if (json_ != nullptr && root_ != nullptr) {
+            AddToRoot();
+        }
+    }
+    if (!is_object()) {
+        LOG_ERROR("is not object, cannot use operator[].");
+    }
+    auto it = children_.begin();
+    while (it != children_.end()) {
+        if ((*it)->key_ == key) {
+            return **it;
+        }
+        ++it;
+    }
+    auto item = cJSON_GetObjectItem(json_, key.c_str());
+    auto res = std::make_shared<JSONWrapper>(item, json_, key);
+    children_.push_back(res);
+    return *res;
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator[](size_t index)
+{
+    if (root_ == nullptr && cJSON_IsNull(json_)) {
+        cJSON_Delete(json_);
+        json_ = nullptr;
+    }
+    if (json_ == nullptr) {
+        json_ = cJSON_CreateArray();
+        if (json_ != nullptr && root_ != nullptr) {
+            AddToRoot();
+        }
+    }
+    if (!is_array()) {
+        LOG_ERROR("is not array, cannot use operator[].");
+    }
+
+    int size = cJSON_GetArraySize(json_);
+    auto len = children_.size();
+    while (len < size) {
+        auto item = cJSON_GetArrayItem(json_, len);
+        children_.push_back(std::make_shared<JSONWrapper>(item, json_));
+        len++;
+    }
+    if (index > len) {
+        LOG_ERROR("cannot use operator[]");
+    }
+    if (index == len) {
+        children_.push_back(std::make_shared<JSONWrapper>(nullptr, json_));
+    }
+    return *children_[index];
+}
+
+Serializable::JSONWrapper &Serializable::JSONWrapper::operator[](size_t index) const
+{
+    if (!is_array()) {
+        LOG_ERROR("invalid args.");
+    }
+    int size = cJSON_GetArraySize(json_);
+    if (index >= size) {
+        LOG_ERROR("invalid args.");
+    }
+    auto len = children_.size();
+    while (len < size) {
+        auto item = cJSON_GetArrayItem(json_, len);
+        children_.push_back(std::make_shared<JSONWrapper>(item, json_));
+        len++;
+    }
+    return *children_[index];
+}
+
+bool Serializable::JSONWrapper::is_null() const
+{
+    return cJSON_IsNull(json_);
+}
+
+bool Serializable::JSONWrapper::is_boolean() const
+{
+    return cJSON_IsBool(json_);
+}
+
+bool Serializable::JSONWrapper::is_number_integer() const
+{
+    if (!cJSON_IsNumber(json_)) {
+        return false;
+    }
+    auto value = cJSON_GetNumberValue(json_);
+    return value == std::floor(value) && value >= std::numeric_limits<int64_t>::min() &&
+        value <= std::numeric_limits<int64_t>::max();
+}
+
+bool Serializable::JSONWrapper::is_number_unsigned() const
+{
+    if (!cJSON_IsNumber(json_)) {
+        return false;
+    }
+    auto value = cJSON_GetNumberValue(json_);
+    return value == std::floor(value) && value >= 0 && value <= std::numeric_limits<uint64_t>::max();
+}
+
+bool Serializable::JSONWrapper::is_number_float() const
+{
+    if (!cJSON_IsNumber(json_)) {
+        return false;
+    }
+    auto value = cJSON_GetNumberValue(json_);
+    if (value == std::floor(value) && value >= std::numeric_limits<int64_t>::min() &&
+                value <= std::numeric_limits<int64_t>::max()) {
+        return false;
+    }
+    return true;
+}
+
+bool Serializable::JSONWrapper::is_string() const
+{
+    return cJSON_IsString(json_);
+}
+
+bool Serializable::JSONWrapper::is_array() const
+{
+    return cJSON_IsArray(json_);
+}
+
+bool Serializable::JSONWrapper::is_object() const
+{
+    return cJSON_IsObject(json_);
+}
+
+bool Serializable::JSONWrapper::is_discarded() const
+{
+    return json_ == nullptr;
+}
+
+bool Serializable::JSONWrapper::accept(const std::string &str)
+{
+    cJSON *json = cJSON_Parse(str.c_str());
+    if (json == nullptr) {
+        return false;
+    }
+
+    cJSON_Delete(json);
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(bool &values) const
+{
+    if (json_ == nullptr || !is_boolean()) {
+        return false;
+    }
+
+    values = cJSON_IsTrue(json_) ? true : false;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(int16_t &values) const
+{
+    if (json_ == nullptr || !is_number_integer()) {
+        return false;
+    }
+    values = json_->valueint;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(uint16_t &values) const
+{
+    if (json_ == nullptr || !is_number_unsigned()) {
+        return false;
+    }
+    values = json_->valueint;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(int32_t &values) const
+{
+    if (json_ == nullptr || !is_number_integer()) {
+        return false;
+    }
+    values = json_->valueint;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(uint32_t &values) const
+{
+    if (json_ == nullptr || !is_number_unsigned()) {
+        return false;
+    }
+    values = json_->valueint;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(int64_t &values) const
+{
+    if (json_ == nullptr || !is_number_integer()) {
+        return false;
+    }
+    values = json_->valueint;
+
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(uint64_t &values) const
+{
+    if (json_ == nullptr || !is_number_unsigned()) {
+        return false;
+    }
+    values = json_->valueint;
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(double &values) const
+{
+    if (json_ == nullptr || !is_number_integer()) {
+        return false;
+    }
+    values = cJSON_GetNumberValue(json_);
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(std::string &values) const
+{
+    if (json_ == nullptr || !is_string()) {
+        return false;
+    }
+    values = cJSON_GetStringValue(json_);
+    return true;
+}
+
+bool Serializable::JSONWrapper::get_to(std::vector<uint8_t> &values) const
+{
+    if (json_ == nullptr || !is_array()) {
+        return false;
+    }
+    auto size = cJSON_GetArraySize(json_);
+    values.clear();
+    values.reserve(size);
+    for (auto i = 0; i < size; i++) {
+        auto item = cJSON_GetArrayItem(json_, i);
+        if (item) {
+            values.push_back(cJSON_GetNumberValue(item));
+        }
+    }
+    return true;
+}
+
+size_t Serializable::JSONWrapper::size() const
+{
+    if (!cJSON_IsArray(json_) && !cJSON_IsObject(json_)) {
+        return 0;
+    }
+    return cJSON_GetArraySize(json_);
+}
+
+std::string Serializable::JSONWrapper::dump() const
+{
+    if (json_ == nullptr) {
+        return "";
+    }
+    return cJSON_PrintUnformatted(json_);
+}
+
+Serializable::iterator Serializable::JSONWrapper::find(const std::string &key) const
+{
+    auto size = cJSON_GetArraySize(json_);
+    auto len = children_.size();
+    if (len != size) {
+        children_.clear();
+        for (int i = 0; i < size; i++) {
+            auto item = cJSON_GetArrayItem(json_, i);
+            children_.push_back(std::make_shared<JSONWrapper>(item, json_, item != nullptr ? item->string : ""));
+        }
+    }
+    auto it = children_.begin();
+    while (it != children_.end()) {
+        if ((*it)->key_ == key) {
+            return it;
+        }
+        ++it;
+    }
+    return it;
+}
+
+Serializable::iterator Serializable::JSONWrapper::begin() const
+{
+    if (json_ == nullptr || (!is_array() && !is_object())) {
+        LOG_ERROR("not support.");
+    }
+    auto size = cJSON_GetArraySize(json_);
+    auto len = children_.size();
+    if (len != size) {
+        children_.clear();
+        for (int i = 0; i < size; i++) {
+            auto item = cJSON_GetArrayItem(json_, i);
+            children_.push_back(std::make_shared<JSONWrapper>(item, json_, item != nullptr ? item->string : ""));
+        }
+    }
+    return children_.begin();
+}
+
+Serializable::iterator Serializable::JSONWrapper::end() const
+{
+    if (json_ == nullptr || json_->child == nullptr || (!is_array() && !is_object())) {
+        LOG_ERROR("not support.");
+    }
+    auto size = cJSON_GetArraySize(json_);
+    auto len = children_.size();
+    if (len != size) {
+        children_.clear();
+        for (int i = 0; i < size; i++) {
+            auto item = cJSON_GetArrayItem(json_, i);
+            children_.push_back(std::make_shared<JSONWrapper>(item, json_, item != nullptr ? item->string : ""));
+        }
+    }
+    return children_.end();
+}
+
+Serializable::JSONWrapper::~JSONWrapper()
+{
+    if (needDel_ && root_ == nullptr && json_ != nullptr) {
+        cJSON_Delete(json_);
+    }
+}
+
+Serializable::JSONWrapper Serializable::JSONWrapper::parse(const std::string &str)
+{
+    return Serializable::JSONWrapper(cJSON_Parse(str.c_str()), nullptr);
+}
+
+bool Serializable::JSONWrapper::operator==(int32_t value) const
+{
+    return value == cJSON_GetNumberValue(json_);
+}
+
+bool Serializable::JSONWrapper::operator==(const std::string &value) const
+{
+    return value == cJSON_GetStringValue(json_);
+}
+
+void Serializable::JSONWrapper::AddToRoot()
+{
+    if (!key_.empty()) {
+        if (!cJSON_AddItemToObject(root_, key_.c_str(), json_)) {
+            cJSON_Delete(json_);
+            json_ = nullptr;
+        } else {
+            needDel_ = false;
+        }
+    } else {
+        if (!cJSON_AddItemToArray(root_, json_)) {
+            cJSON_Delete(json_);
+            json_ = nullptr;
+        } else {
+            needDel_ = false;
+        }
+    }
+}
+
+Serializable::iterator::iterator(std::vector<std::shared_ptr<JSONWrapper>>::iterator it) : node_(it)
+{
+}
+
+Serializable::iterator &Serializable::iterator::operator++()
+{
+    node_++;
+    return *this;
+}
+
+bool Serializable::iterator::operator==(const Serializable::iterator &iter) const
+{
+    return node_ == iter.node_;
+}
+
+bool Serializable::iterator::operator!=(const Serializable::iterator &iter) const
+{
+    return !operator==(iter);
+}
+
+const Serializable::JSONWrapper &Serializable::iterator::operator*() const
+{
+    return **node_;
+}
+
+std::string Serializable::iterator::key() const
+{
+    return (*node_)->key_;
+}
+
+const Serializable::JSONWrapper &Serializable::iterator::value() const
+{
+    return operator*();
+}
+
+bool Serializable::JSONWrapper::empty() const
+{
+    if (json_ == nullptr) {
+        return true;
+    }
+    if (cJSON_IsNull(json_)) {
+        return true;
+    }
+    if (cJSON_IsArray(json_)) {
+        return cJSON_GetArraySize(json_) == 0;
+    }
+    if (cJSON_IsObject(json_)) {
+        int size = 0;
+        cJSON *child = json_->child;
+        while (child) {
+            size++;
+            child = child->next;
+        }
+        return size == 0;
+    }
+    return false;
+}
+
+std::string Serializable::JSONWrapper::to_string(const JSONWrapper &jsonWrapper)
+{
+    return jsonWrapper.dump();
+}
+
+std::vector<std::string> Serializable::JSONWrapper::Keys() const
+{
+    std::vector<std::string> keys;
+    cJSON *item;
+    cJSON *current = json_;
+    cJSON_ArrayForEach(item, current) {
+        auto *key = item->string;
+        keys.emplace_back(key);
+    }
+    return keys;
+}
 } // namespace OHOS
diff --git a/frameworks/native/gdb/include/full_result.h b/frameworks/native/gdb/include/full_result.h
index 648ebaf9f2793588c8ebdf08b5461779c5240dc7..23832527751410fe10a3c89d9238f76a185874e2 100644
--- a/frameworks/native/gdb/include/full_result.h
+++ b/frameworks/native/gdb/include/full_result.h
@@ -24,7 +24,6 @@
 
 #include "edge.h"
 #include "gdb_store_config.h"
-#include "nlohmann/json.hpp"
 #include "path.h"
 #include "result.h"
 #include "vertex.h"
diff --git a/frameworks/native/gdb/include/gdb_utils.h b/frameworks/native/gdb/include/gdb_utils.h
index 055e91c3b66d89a5076ec5674ad587fb59c3c12c..cc7cc2527b4e7ca12deddd68abcff9a1352b2447 100644
--- a/frameworks/native/gdb/include/gdb_utils.h
+++ b/frameworks/native/gdb/include/gdb_utils.h
@@ -16,6 +16,7 @@
 #ifndef OHOS_DISTRIBUTED_DATA_NATIVE_GDB_GDB_UTILS_H
 #define OHOS_DISTRIBUTED_DATA_NATIVE_GDB_GDB_UTILS_H
 #include <string>
+#include <vector>
 
 #include "rdb_visibility.h"
 
diff --git a/frameworks/native/gdb/include/graph_statement.h b/frameworks/native/gdb/include/graph_statement.h
index 5f4d3c2385066b7e186624a908a5d4dc6ef0f994..dd28522df9282754ef026a4824e8c8b35ae22fca 100644
--- a/frameworks/native/gdb/include/graph_statement.h
+++ b/frameworks/native/gdb/include/graph_statement.h
@@ -21,7 +21,6 @@
 #endif
 #include "connection.h"
 #include "grd_adapter.h"
-#include "nlohmann/json.hpp"
 #include "statement.h"
 
 namespace OHOS::DistributedDataAip {
diff --git a/frameworks/native/gdb/src/edge.cpp b/frameworks/native/gdb/src/edge.cpp
index 1b3fb582ddea929326b1ab327ad7912f93be60fb..daa3a28097250f50c924d8c60824827ad3986546 100644
--- a/frameworks/native/gdb/src/edge.cpp
+++ b/frameworks/native/gdb/src/edge.cpp
@@ -13,6 +13,8 @@
  * limitations under the License.
  */
 #define LOG_TAG "GdbEdge"
+#include "edge.h"
+
 #include <utility>
 
 #include "gdb_errors.h"
@@ -20,12 +22,12 @@
 #include "logger.h"
 
 namespace OHOS::DistributedDataAip {
-Edge::Edge() : Vertex(), sourceId_("0"), targetId_("0")
+Edge::Edge() : id_("0"), properties_(), sourceId_("0"), targetId_("0")
 {
 }
 
 Edge::Edge(std::string id, std::string label, std::string sourceId, std::string targetId)
-    : Vertex(std::move(id), std::move(label)), sourceId_(std::move(sourceId)), targetId_(std::move(targetId))
+    : id_(std::move(id)), label_(std::move(label)), sourceId_(std::move(sourceId)), targetId_(std::move(targetId))
 {
 }
 
@@ -39,6 +41,36 @@ Edge::Edge(const std::shared_ptr<Vertex> &element, std::string sourceId, std::st
     }
 }
 
+std::string Edge::GetId() const
+{
+    return id_;
+}
+
+void Edge::SetId(std::string id)
+{
+    id_ = std::move(id);
+}
+
+const std::string &Edge::GetLabel() const
+{
+    return label_;
+}
+
+void Edge::SetLabel(const std::string &label)
+{
+    label_ = label;
+}
+
+const std::unordered_map<std::string, PropType> &Edge::GetProperties() const
+{
+    return properties_;
+}
+
+void Edge::SetProperty(const std::string &key, PropType value)
+{
+    properties_[key] = std::move(value);
+}
+
 std::string Edge::GetSourceId() const
 {
     return sourceId_;
@@ -59,46 +91,31 @@ void Edge::SetTargetId(std::string targetId)
     targetId_ = std::move(targetId);
 }
 
-std::string Edge::GetIdFromJson(const std::string &key, const nlohmann::json &json, int32_t &errCode)
+bool Edge::Marshal(json &node) const
 {
-    if (key.empty() || (!json.at(key).is_string() && !json.at(key).is_number())) {
-        LOG_ERROR("edge start or end id is not number or string. jsonStr=%{public}s", json.dump().c_str());
-        errCode = E_PARSE_JSON_FAILED;
-        return "";
-    }
-    errCode = E_OK;
-    if (json.at(key).is_number()) {
-        auto sourceId = json.at(key).get<int32_t>();
-        return std::to_string(sourceId);
-    }
-    if (json.at(key).is_string()) {
-        return json.at(key).get<std::string>();
-    }
-    errCode = E_PARSE_JSON_FAILED;
-    return "";
+    return false;
+}
+
+bool Edge::Unmarshal(const json &node)
+{
+    bool isUnmarshalSuccess = true;
+    isUnmarshalSuccess = Vertex::GetID(node, ID, id_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = GetValue(node, LABEL, label_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = Vertex::GetID(node, SOURCEID, sourceId_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = Vertex::GetID(node, TARGETID, targetId_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = Vertex::GetPropsValue(node, PROPERTIES, properties_) && isUnmarshalSuccess;
+    return isUnmarshalSuccess;
 }
 
-std::shared_ptr<Edge> Edge::Parse(const nlohmann::json &json, int32_t &errCode)
+std::shared_ptr<Edge> Edge::Parse(const std::string &jsonStr, int32_t &errCode)
 {
-    if (!json.contains(Edge::SOURCEID) || !json.contains(Edge::TARGETID)) {
-        LOG_ERROR("edge format error. jsonStr=%{public}s", json.dump().c_str());
+    Edge edge;
+    if (!Serializable::Unmarshall(jsonStr, edge)) {
+        LOG_WARN("Parse edge failed.");
         errCode = E_PARSE_JSON_FAILED;
         return nullptr;
     }
     errCode = E_OK;
-    std::shared_ptr<Vertex> element = Vertex::Parse(json, errCode);
-    if (errCode != E_OK || element == nullptr) {
-        LOG_ERROR("parse edge element failed. jsonStr=%{public}s", json.dump().c_str());
-        return nullptr;
-    }
-    auto sourceId = Edge::GetIdFromJson(Edge::SOURCEID, json, errCode);
-    if (errCode != E_OK) {
-        return nullptr;
-    }
-    auto targetId = Edge::GetIdFromJson(Edge::TARGETID, json, errCode);
-    if (errCode != E_OK) {
-        return nullptr;
-    }
-    return std::make_shared<Edge>(element, sourceId, targetId);
+    return std::make_shared<Edge>(edge);
 }
 } // namespace OHOS::DistributedDataAip
diff --git a/frameworks/native/gdb/src/graph_statement.cpp b/frameworks/native/gdb/src/graph_statement.cpp
index d1d0b3ce4beed4e7e85cb296c08271bac1891c90..bd955a755e86642dcb5de44ba3de9b94f5cfdba3 100644
--- a/frameworks/native/gdb/src/graph_statement.cpp
+++ b/frameworks/native/gdb/src/graph_statement.cpp
@@ -17,13 +17,15 @@
 
 #include <utility>
 
-#include "gdb_errors.h"
 #include "connection.h"
 #include "full_result.h"
+#include "gdb_errors.h"
 #include "grd_error.h"
 #include "logger.h"
+#include "serializable.h"
 
 namespace OHOS::DistributedDataAip {
+using json = OHOS::Serializable::JSONWrapper;
 GraphStatement::GraphStatement(GRD_DB *db, const std::string &gql, std::shared_ptr<Connection> conn, int32_t &errCode)
     : conn_(conn), gql_(gql), dbHandle_(db)
 {
@@ -119,36 +121,30 @@ std::pair<int32_t, ColumnType> GraphStatement::GetColumnType(int32_t index) cons
 
 GraphValue GraphStatement::ParseJsonStr(const std::string &jsonStr, int32_t &errCode)
 {
+    errCode = E_OK;
     if (jsonStr.empty()) {
         LOG_WARN("parse json string. jsonStr is empty");
-        errCode = E_OK;
         return nullptr;
     }
-    nlohmann::json json = nlohmann::json::parse(jsonStr, nullptr, false);
-    if (json.is_discarded()) {
+    json jsonObj = json::parse(jsonStr);
+    if (jsonObj.is_discarded() || jsonObj.is_null()) {
         LOG_ERROR("parse json string failed. jsonStr=%{public}s", jsonStr.c_str());
         errCode = E_PARSE_JSON_FAILED;
         return nullptr;
     }
-
-    errCode = E_OK;
-    if (json.is_null()) {
-        LOG_WARN("parse json string. jsonStr is empty");
-        return nullptr;
-    }
-    if (!json.is_object()) {
+    if (!jsonObj.is_object()) {
         LOG_ERROR("json format error. jsonStr=%{public}s", jsonStr.c_str());
         errCode = E_PARSE_JSON_FAILED;
         return nullptr;
     }
 
-    if (json.contains(Path::SEGMENTS)) {
-        return Path::Parse(json, errCode);
+    if (jsonObj.find(Path::SEGMENTS) != jsonObj.end()) {
+        return Path::Parse(jsonStr, errCode);
     }
-    if (json.contains(Edge::SOURCEID) && json.contains(Edge::TARGETID)) {
-        return Edge::Parse(json, errCode);
+    if (jsonObj.find(Edge::SOURCEID) != jsonObj.end() && jsonObj.find(Edge::TARGETID) != jsonObj.end()) {
+        return Edge::Parse(jsonStr, errCode);
     }
-    return Vertex::Parse(json, errCode);
+    return Vertex::Parse(jsonStr, errCode);
 }
 
 std::pair<int32_t, GraphValue> GraphStatement::GetColumnValue(int32_t index) const
diff --git a/frameworks/native/gdb/src/path.cpp b/frameworks/native/gdb/src/path.cpp
index d390b319d052658590c0f6d64121018a312c276c..67ce8d9bd6fdcd7c5748c64c08aa83837bf999e3 100644
--- a/frameworks/native/gdb/src/path.cpp
+++ b/frameworks/native/gdb/src/path.cpp
@@ -71,41 +71,37 @@ const std::vector<std::shared_ptr<PathSegment>> &Path::GetSegments() const
     return segments_;
 }
 
-std::shared_ptr<Path> Path::Parse(const nlohmann::json &json, int32_t &errCode)
+bool Path::Marshal(json &node) const
 {
-    if (!json.contains(Path::PATHLEN) || !json.contains(Path::START) || !json.at(Path::START).is_object() ||
-        !json.contains(Path::END) || !json.at(Path::END).is_object() || !json.contains(Path::SEGMENTS) ||
-        !json.at(Path::SEGMENTS).is_array() || !json.at(Path::PATHLEN).is_number_unsigned()) {
-        LOG_ERROR("path format error. jsonStr=%{public}s", json.dump().c_str());
-        errCode = E_PARSE_JSON_FAILED;
-        return nullptr;
-    }
-    errCode = E_OK;
+    return false;
+}
 
-    auto pathLen = json.at(Path::PATHLEN).get<uint32_t>();
-    auto start = Vertex::Parse(json.at(Path::START), errCode);
-    if (errCode != E_OK) {
-        return nullptr;
+bool Path::Unmarshal(const json &node)
+{
+    bool isUnmarshalSuccess = true;
+    isUnmarshalSuccess = GetValue(node, PATHLEN, pathLen_) && isUnmarshalSuccess;
+    if (start_ == nullptr) {
+        start_ = std::make_shared<Vertex>();
     }
+    isUnmarshalSuccess = GetValue(node, START, start_) && isUnmarshalSuccess;
+    if (end_ == nullptr) {
+        end_ = std::make_shared<Vertex>();
+    }
+    isUnmarshalSuccess = GetValue(node, END, end_) && isUnmarshalSuccess;
+
+    isUnmarshalSuccess = GetValue(node, SEGMENTS, segments_) && isUnmarshalSuccess;
+    return isUnmarshalSuccess;
+}
 
-    auto end = Vertex::Parse(json.at(Path::END), errCode);
-    if (errCode != E_OK) {
+std::shared_ptr<Path> Path::Parse(const std::string &jsonStr, int32_t &errCode)
+{
+    Path path;
+    if (!Serializable::Unmarshall(jsonStr, path)) {
+        LOG_WARN("Parse path failed.");
+        errCode = E_PARSE_JSON_FAILED;
         return nullptr;
     }
-    auto pathSegments = std::vector<std::shared_ptr<PathSegment>>();
-    for (const auto &item : json.at(Path::SEGMENTS)) {
-        if (!item.is_object()) {
-            LOG_ERROR("pathItem format error. jsonStr=%{public}s", json.dump().c_str());
-            return nullptr;
-        }
-        auto pathSegment = PathSegment::Parse(item, errCode);
-        if (errCode != E_OK) {
-            return nullptr;
-        }
-        pathSegments.push_back(pathSegment);
-    }
     errCode = E_OK;
-    return std::make_shared<Path>(start, end, pathLen, pathSegments);
-    ;
+    return std::make_shared<Path>(path);
 }
 } // namespace OHOS::DistributedDataAip
diff --git a/frameworks/native/gdb/src/path_segment.cpp b/frameworks/native/gdb/src/path_segment.cpp
index a4c501eb63aff826abe9b896a80c3642f6b945df..7f26c43e48d9eb596f772a0223b0f8087b0e521c 100644
--- a/frameworks/native/gdb/src/path_segment.cpp
+++ b/frameworks/native/gdb/src/path_segment.cpp
@@ -60,35 +60,40 @@ void PathSegment::SetTargetVertex(std::shared_ptr<Vertex> vertex)
     targetVertex_ = vertex;
 }
 
-std::shared_ptr<PathSegment> PathSegment::Parse(const nlohmann::json &json, int32_t &errCode)
+bool PathSegment::Marshal(json &node) const
 {
-    if (!json.contains(PathSegment::SOURCE_VERTEX) || !json.at(PathSegment::SOURCE_VERTEX).is_object() ||
-        !json.contains(PathSegment::EDGE) || !json.at(PathSegment::EDGE).is_object() ||
-        !json.contains(PathSegment::TARGET_VERTEX) || !json.at(PathSegment::TARGET_VERTEX).is_object()) {
-        LOG_ERROR("pathSegment format error. jsonStr=%{public}s", json.dump().c_str());
-        errCode = E_PARSE_JSON_FAILED;
-        return nullptr;
+    return true;
+}
+
+bool PathSegment::Unmarshal(const json &node)
+{
+    bool isUnmarshalSuccess = true;
+    if (sourceVertex_ == nullptr) {
+        sourceVertex_ = std::make_shared<Vertex>();
     }
-    errCode = E_OK;
-    std::shared_ptr<PathSegment> segment = std::make_shared<PathSegment>();
-    auto sourceVertex = Vertex::Parse(json.at(PathSegment::SOURCE_VERTEX), errCode);
-    if (errCode != E_OK) {
-        return nullptr;
+    isUnmarshalSuccess = GetValue(node, SOURCE_VERTEX, sourceVertex_) && isUnmarshalSuccess;
+
+    if (targetVertex_ == nullptr) {
+        targetVertex_ = std::make_shared<Vertex>();
     }
-    segment->SetSourceVertex(sourceVertex);
+    isUnmarshalSuccess = GetValue(node, TARGET_VERTEX, targetVertex_) && isUnmarshalSuccess;
 
-    auto edge = Edge::Parse(json.at(PathSegment::EDGE), errCode);
-    if (errCode != E_OK) {
-        return nullptr;
+    if (edge_ == nullptr) {
+        edge_ = std::make_shared<Edge>();
     }
-    segment->SetEdge(edge);
+    isUnmarshalSuccess = GetValue(node, EDGE, edge_) && isUnmarshalSuccess;
+    return isUnmarshalSuccess;
+}
 
-    auto targetVertex = Vertex::Parse(json.at(PathSegment::TARGET_VERTEX), errCode);
-    if (errCode != E_OK) {
+std::shared_ptr<PathSegment> PathSegment::Parse(const std::string &jsonStr, int32_t &errCode)
+{
+    PathSegment pathSegment;
+    if (!Serializable::Unmarshall(jsonStr, pathSegment)) {
+        LOG_WARN("Parse pathSegment failed.");
+        errCode = E_PARSE_JSON_FAILED;
         return nullptr;
     }
-    segment->SetTargetVertex(targetVertex);
-
-    return segment;
+    errCode = E_OK;
+    return std::make_shared<PathSegment>(pathSegment);
 }
 } // namespace OHOS::DistributedDataAip
diff --git a/frameworks/native/gdb/src/vertex.cpp b/frameworks/native/gdb/src/vertex.cpp
index ffdb97d5e8c54a10b94ae944ac6a2fd81d84951b..ddd88d576b4c8e7140906c15eb3f12c0faca81ca 100644
--- a/frameworks/native/gdb/src/vertex.cpp
+++ b/frameworks/native/gdb/src/vertex.cpp
@@ -12,7 +12,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "GdbElement"
+#define LOG_TAG "GdbVertex"
+#include "vertex.h"
+
 #include <utility>
 
 #include "gdb_errors.h"
@@ -26,14 +28,12 @@ Vertex::Vertex() : id_("0"), properties_()
 
 Vertex::Vertex(std::string id, std::string label) : id_(std::move(id)), label_(std::move(label))
 {
-    labels_.emplace_back(label_);
 }
 
 Vertex::Vertex(std::string id, std::string label,
     const std::unordered_map<std::string, PropType> &properties)
     : id_(std::move(id)), label_(std::move(label)), properties_(properties)
 {
-    labels_.emplace_back(label_);
 }
 
 std::string Vertex::GetId() const
@@ -51,15 +51,16 @@ const std::string &Vertex::GetLabel() const
     return label_;
 }
 
-const std::vector<std::string> &Vertex::GetLabels() const
+const std::vector<std::string> &Vertex::GetLabels()
 {
+    labels_.clear();
+    labels_.emplace_back(label_);
     return labels_;
 }
 
 void Vertex::SetLabel(const std::string &label)
 {
     label_ = label;
-    labels_.emplace_back(label);
 }
 
 const std::unordered_map<std::string, PropType> &Vertex::GetProperties() const
@@ -72,51 +73,85 @@ void Vertex::SetProperty(const std::string &key, PropType value)
     properties_[key] = std::move(value);
 }
 
-std::shared_ptr<Vertex> Vertex::Parse(const nlohmann::json &json, int32_t &errCode)
+bool Vertex::Marshal(json &node) const
 {
-    std::shared_ptr<Vertex> element = std::make_shared<Vertex>();
-    if (!json.contains(Vertex::LABEL) || !json.contains(Vertex::ID) ||
-        !json.contains(Vertex::PROPERTIES) || !json.at(Vertex::PROPERTIES).is_object()) {
-        LOG_ERROR("element format error.");
-        errCode = E_PARSE_JSON_FAILED;
-        return nullptr;
+    return false;
+}
+
+bool Vertex::GetID(const json &node, const std::string &name, std::string &id)
+{
+    std::string strId;
+    const auto ret = GetValue(node, name, strId);
+    if (!ret) {
+        uint64_t intId;
+        if (GetValue(node, name, intId)) {
+            strId = std::to_string(intId);
+        } else {
+            return false;
+        }
     }
+    id = std::move(strId);
+    return true;
+}
 
-    if (json.at(Vertex::ID).is_number()) {
-        auto id = json.at(Vertex::ID).get<int32_t>();
-        element->SetId(std::to_string(id));
-    } else if (json.at(Vertex::ID).is_string()) {
-        auto id = json.at(Vertex::ID).get<std::string>();
-        element->SetId(id);
-    } else {
-        LOG_ERROR("element id is not number or string.");
-        errCode = E_PARSE_JSON_FAILED;
-        return nullptr;
+bool Vertex::GetPropsValue(const json &node, const std::string &name, std::unordered_map<std::string, PropType> &props)
+{
+    auto &propsNode = GetSubNode(node, name);
+    if (propsNode.is_discarded() || propsNode.is_null()) {
+        LOG_WARN("propsNode is discarded.");
+        return true;
     }
-    if (!json.at(Vertex::LABEL).is_string()) {
-        LOG_ERROR("element label is not string.");
-        errCode = E_PARSE_JSON_FAILED;
-        return nullptr;
+    if (!propsNode.is_object()) {
+        LOG_ERROR("propsNode is not object.");
+        return false;
     }
-    element->SetLabel(json.at(Vertex::LABEL).get<std::string>());
-    for (const auto &[key, value] : json.at(Vertex::PROPERTIES).items()) {
-        if (value.is_string()) {
-            element->SetProperty(key, value.get<std::string>());
-        } else if (value.is_number_integer()) {
-            element->SetProperty(key, value.get<int64_t>());
-        } else if (value.is_number_float()) {
-            element->SetProperty(key, value.get<double>());
-        } else if (value.is_boolean()) {
-            element->SetProperty(key, value.get<bool>());
-        } else if (value.is_null()) {
-            element->SetProperty(key, nullptr);
+    auto keys = propsNode.Keys();
+    for (const auto &key : keys) {
+        auto &valueObj = GetSubNode(propsNode, key);
+        if (valueObj.is_boolean()) {
+            bool boolValue;
+            valueObj.get_to(boolValue);
+            props.emplace(key, boolValue);
+        } else if (valueObj.is_string()) {
+            std::string stringValue;
+            valueObj.get_to(stringValue);
+            props.emplace(key, stringValue);
+        } else if (valueObj.is_number_unsigned() || valueObj.is_number_integer()) {
+            int64_t int64Value;
+            valueObj.get_to(int64Value);
+            props.emplace(key, int64Value);
+        } else if (valueObj.is_number_float()) {
+            double doubleValue;
+            valueObj.get_to(doubleValue);
+            props.emplace(key, doubleValue);
+        } else if (valueObj.is_null()) {
+            LOG_WARN("element is null. key: %{public}s", key.c_str());
         } else {
-            LOG_ERROR("element property value type is not supported.");
-            errCode = E_PARSE_JSON_FAILED;
-            return nullptr;
+            LOG_WARN("element type of properties not support. key: %{public}s", key.c_str());
+            return false;
         }
     }
+    return true;
+}
+
+bool Vertex::Unmarshal(const json &node)
+{
+    bool isUnmarshalSuccess = true;
+    isUnmarshalSuccess = GetID(node, ID, id_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = GetValue(node, LABEL, label_) && isUnmarshalSuccess;
+    isUnmarshalSuccess = Vertex::GetPropsValue(node, PROPERTIES, properties_) && isUnmarshalSuccess;
+    return isUnmarshalSuccess;
+}
+
+std::shared_ptr<Vertex> Vertex::Parse(const std::string &jsonStr, int32_t &errCode)
+{
+    Vertex vertex;
+    if (!Serializable::Unmarshall(jsonStr, vertex)) {
+        LOG_WARN("Parse vertex failed.");
+        errCode = E_PARSE_JSON_FAILED;
+        return nullptr;
+    }
     errCode = E_OK;
-    return element;
+    return std::make_shared<Vertex>(vertex);
 }
 } // namespace OHOS::DistributedDataAip
diff --git a/frameworks/native/rdb/src/knowledge_schema_helper.cpp b/frameworks/native/rdb/src/knowledge_schema_helper.cpp
index a1f51056473dd0834073bad93a819c1014487b6d..f8653c0464f2a219597d14b451368d2cdf5b6656 100644
--- a/frameworks/native/rdb/src/knowledge_schema_helper.cpp
+++ b/frameworks/native/rdb/src/knowledge_schema_helper.cpp
@@ -22,14 +22,14 @@
 #include <sstream>
 #include <regex>
 #include "logger.h"
-#include "nlohmann/json.hpp"
+#include "serializable.h"
 #include "rdb_errno.h"
 #include "sqlite_utils.h"
 #include "task_executor.h"
 
 namespace OHOS::NativeRdb {
 using namespace OHOS::Rdb;
-using Json = nlohmann::json;
+using Json = Serializable::JSONWrapper;
 
 constexpr uint16_t SCHEMA_FIELD_MIN_LEN = 1;
 constexpr uint16_t SCHEMA_FIELD_MAX_LEN = 255;
diff --git a/interfaces/inner_api/appdatafwk/BUILD.gn b/interfaces/inner_api/appdatafwk/BUILD.gn
index f327747e5012a2c25850ef57b44bd308221ba86a..041da6595efe1f6099b7742535c406982d656d80 100644
--- a/interfaces/inner_api/appdatafwk/BUILD.gn
+++ b/interfaces/inner_api/appdatafwk/BUILD.gn
@@ -98,6 +98,10 @@ if (is_android || is_ios) {
       ":common_public_config",
       ":appdatafwk_public_config",
     ]
+    external_deps = [
+      "cJSON:cjson",
+      "hilog:libhilog",
+    ]
 
     subsystem_name = "distributeddatamgr"
     part_name = "relational_store"
@@ -127,6 +131,7 @@ ohos_shared_library("native_appdatafwk") {
 
   external_deps = [
     "c_utils:utils",
+    "cJSON:cjson",
     "hilog:libhilog",
     "ipc:ipc_single",
   ]
diff --git a/interfaces/inner_api/appdatafwk/include/serializable.h b/interfaces/inner_api/appdatafwk/include/serializable.h
index b4fd7f8f8f48ecc489cf6f8fb9fd4441d1d9bffb..d0034b4c79d9143ba5ee740d9f5c55a5a2d372dd 100644
--- a/interfaces/inner_api/appdatafwk/include/serializable.h
+++ b/interfaces/inner_api/appdatafwk/include/serializable.h
@@ -15,6 +15,8 @@
 
 #ifndef DISTRIBUTED_RDB_SERIALIZABLE_H
 #define DISTRIBUTED_RDB_SERIALIZABLE_H
+#include <map>
+#include <memory>
 #include <string>
 #include <vector>
 
@@ -22,23 +24,108 @@
 #ifndef JSON_NOEXCEPTION
 #define JSON_NOEXCEPTION
 #endif
-#include <nlohmann/json.hpp>
+struct cJSON;
 namespace OHOS {
 #ifndef GET_NAME
 #define GET_NAME(value) #value
 #endif
 struct Serializable {
 public:
-    using json = nlohmann::json;
-    using size_type = nlohmann::json::size_type;
-    using error_handler_t = nlohmann::detail::error_handler_t;
+    class iterator;
+    class JSONWrapper final {
+    public:
+        friend iterator;
+        enum class Type : uint8_t {
+            ARRAY,
+            OBJECT,
+        };
+        API_EXPORT JSONWrapper();
+        JSONWrapper(cJSON *json, cJSON *root, const std::string &key = "");
+        JSONWrapper(const std::string &jsonStr);
+        JSONWrapper(JSONWrapper &&jsonWrapper);
+
+        operator std::string() const;
+        bool operator==(int32_t value) const;
+        bool operator==(const std::string &value) const;
+
+        JSONWrapper &operator=(JSONWrapper &&jsonWrapper);
+        JSONWrapper &operator=(bool value);
+        JSONWrapper &operator=(int32_t value);
+        JSONWrapper &operator=(uint32_t value);
+        JSONWrapper &operator=(int64_t value);
+        JSONWrapper &operator=(uint64_t value);
+        JSONWrapper &operator=(double value);
+        JSONWrapper &operator=(const char *value);
+        JSONWrapper &operator=(const std::string &value);
+        JSONWrapper &operator=(const std::vector<uint8_t> &value);
+        API_EXPORT JSONWrapper &operator=(JSONWrapper::Type type);
+        API_EXPORT JSONWrapper &operator[](const std::string &key);
+        API_EXPORT JSONWrapper &operator[](size_t index);
+        API_EXPORT JSONWrapper &operator[](size_t index) const;
+
+        API_EXPORT bool is_null() const;
+        API_EXPORT bool is_boolean() const;
+        API_EXPORT bool is_number_integer() const;
+        API_EXPORT bool is_number_unsigned() const;
+        API_EXPORT bool is_number_float() const;
+        API_EXPORT bool is_string() const;
+        API_EXPORT bool is_array() const;
+        API_EXPORT bool is_object() const;
+        API_EXPORT bool is_discarded() const;
+
+        API_EXPORT bool get_to(bool &values) const;
+        API_EXPORT bool get_to(int16_t &values) const;
+        API_EXPORT bool get_to(uint16_t &values) const;
+        API_EXPORT bool get_to(int32_t &values) const;
+        API_EXPORT bool get_to(uint32_t &values) const;
+        API_EXPORT bool get_to(int64_t &values) const;
+        API_EXPORT bool get_to(uint64_t &values) const;
+        API_EXPORT bool get_to(double &values) const;
+        API_EXPORT bool get_to(std::string &values) const;
+        API_EXPORT bool get_to(std::vector<uint8_t> &values) const;
+        API_EXPORT size_t size() const;
+        API_EXPORT std::string dump() const;
+        API_EXPORT iterator find(const std::string &key) const;
+        API_EXPORT iterator begin() const;
+        API_EXPORT iterator end() const;
+        API_EXPORT ~JSONWrapper();
+        API_EXPORT static JSONWrapper parse(const std::string &str);
+        static bool accept(const std::string &str);
+
+        API_EXPORT bool empty() const;
+        API_EXPORT static std::string to_string(const JSONWrapper &jsonWrapper);
+        API_EXPORT std::vector<std::string> Keys() const;
+    private:
+        void AddToRoot();
+        JSONWrapper(const JSONWrapper &jsonWrapper) = delete;
+        JSONWrapper &operator=(const JSONWrapper &jsonWrapper) = delete;
+        cJSON *json_ = nullptr;
+        cJSON *root_ = nullptr;
+        std::string key_;
+        bool needDel_ = false;
+        mutable std::vector<std::shared_ptr<JSONWrapper>> children_;
+    };
+    class iterator {
+    public:
+        iterator(std::vector<std::shared_ptr<JSONWrapper>>::iterator it);
+        iterator &operator++();
+        API_EXPORT bool operator==(const iterator &iter) const;
+        API_EXPORT bool operator!=(const iterator &iter) const;
+        const JSONWrapper &operator*() const;
+        std::string key() const;
+        const JSONWrapper &value() const;
+
+    private:
+        std::vector<std::shared_ptr<JSONWrapper>>::iterator node_;
+    };
+    using json = JSONWrapper;
     API_EXPORT json Marshall() const;
     template<typename T>
     static std::string Marshall(T &values)
     {
         json root;
         SetValue(root, values);
-        return root.dump(-1, ' ', false, error_handler_t::replace);
+        return root.dump();
     }
 
     API_EXPORT bool Unmarshall(const std::string &jsonStr);
@@ -59,6 +146,7 @@ public:
     API_EXPORT static bool GetValue(const json &node, const std::string &name, bool &value);
     API_EXPORT static bool GetValue(const json &node, const std::string &name, std::vector<uint8_t> &value);
     API_EXPORT static bool GetValue(const json &node, const std::string &name, Serializable &value);
+    API_EXPORT static bool GetValue(const json &node, const std::string &name, std::shared_ptr<Serializable> value);
     API_EXPORT static bool SetValue(json &node, const std::string &value);
     API_EXPORT static bool SetValue(json &node, const uint32_t &value);
     API_EXPORT static bool SetValue(json &node, const int32_t &value);
@@ -97,8 +185,28 @@ protected:
             return false;
         }
         bool result = true;
-        values.resize(subNode.size());
-        for (size_type i = 0; i < subNode.size(); ++i) {
+        auto size = subNode.size();
+        values.resize(size);
+        for (size_t i = 0; i < size; ++i) {
+            result = GetValue(subNode[i], "", values[i]) && result;
+        }
+        return result;
+    }
+
+    template<typename T>
+    static bool GetValue(const json &node, const std::string &name, std::vector<std::shared_ptr<T>> &values)
+    {
+        auto &subNode = GetSubNode(node, name);
+        if (subNode.is_null() || !subNode.is_array()) {
+            return false;
+        }
+        bool result = true;
+        auto size = subNode.size();
+        values.resize(size);
+        for (size_t i = 0; i < size; ++i) {
+            if (values[i] == nullptr) {
+                values[i] = std::make_shared<T>();
+            }
             result = GetValue(subNode[i], "", values[i]) && result;
         }
         return result;
@@ -108,8 +216,8 @@ protected:
     static bool SetValue(json &node, const std::vector<T> &values)
     {
         bool result = true;
-        size_type i = 0;
-        node = json::value_t::array;
+        size_t i = 0;
+        node = JSONWrapper::Type::ARRAY;
         for (const auto &value : values) {
             result = SetValue(node[i], value) && result;
             i++;
diff --git a/interfaces/inner_api/gdb/BUILD.gn b/interfaces/inner_api/gdb/BUILD.gn
index b7e00d2951702d3e8a9f3491620b64fa38d80778..8b052e8bdf0d8a2d1f5b6ff0adb80ca2bc10f174 100644
--- a/interfaces/inner_api/gdb/BUILD.gn
+++ b/interfaces/inner_api/gdb/BUILD.gn
@@ -64,14 +64,14 @@ ohos_shared_library("native_graphstore") {
     "${relational_store_native_path}/rdb/src/sqlite_utils.cpp",
     "${relational_store_native_path}/rdb/src/string_utils.cpp",
   ]
-  deps = []
+  deps = [ "${relational_store_innerapi_path}/appdatafwk:relational_common_base" ]
   external_deps = [
     "c_utils:utils",
+    "cJSON:cjson",
     "file_api:securitylabel",
     "hilog:libhilog",
     "hisysevent:libhisysevent",
     "hitrace:hitrace_meter",
-    "json:nlohmann_json_static",
   ]
   if (arkdata_db_core_is_exists) {
     defines = [ "ARKDATA_DB_CORE_IS_EXISTS" ]
diff --git a/interfaces/inner_api/gdb/include/edge.h b/interfaces/inner_api/gdb/include/edge.h
index 7414be4043d7aaadf5eeb6f9201c8f578e02f816..f6b34f071ec5a8f93c2e5db1649b993794e6b667 100644
--- a/interfaces/inner_api/gdb/include/edge.h
+++ b/interfaces/inner_api/gdb/include/edge.h
@@ -23,30 +23,47 @@
 #include <variant>
 #include <vector>
 
-#include "nlohmann/json.hpp"
 #include "rdb_visibility.h"
 #include "vertex.h"
 
 namespace OHOS::DistributedDataAip {
-class Edge : public Vertex {
+class Edge final : public Serializable {
 public:
     API_EXPORT Edge();
     API_EXPORT Edge(std::string id, std::string label, std::string sourceId, std::string targetId);
     API_EXPORT Edge(const std::shared_ptr<Vertex> &element, std::string sourceId, std::string targetId);
-    static std::shared_ptr<Edge> Parse(const nlohmann::json &json, int32_t &errCode);
+    static std::shared_ptr<Edge> Parse(const std::string &jsonStr, int32_t &errCode);
+
+    API_EXPORT std::string GetId() const;
+    API_EXPORT void SetId(std::string id);
+
+    API_EXPORT const std::string &GetLabel() const;
+    API_EXPORT void SetLabel(const std::string &label);
+
+    API_EXPORT const std::unordered_map<std::string, PropType> &GetProperties() const;
+    API_EXPORT void SetProperty(const std::string &key, PropType value);
+
     API_EXPORT std::string GetSourceId() const;
     API_EXPORT void SetSourceId(std::string sourceId);
 
     API_EXPORT std::string GetTargetId() const;
     API_EXPORT void SetTargetId(std::string targetId);
 
+    bool Marshal(json &node) const override;
+    bool Unmarshal(const json &node) override;
+
+    static constexpr const char *ID = "identity";
+    static constexpr const char *LABEL = "label";
+    static constexpr const char *PROPERTIES = "properties";
     static constexpr const char *SOURCEID = "start";
     static constexpr const char *TARGETID = "end";
 
 private:
+    std::string id_;
+    std::string label_;
+    std::unordered_map<std::string, PropType> properties_;
     std::string sourceId_;
     std::string targetId_;
-    static std::string GetIdFromJson(const std::string &key, const nlohmann::json &json, int32_t &errCode);
 };
 
 }
diff --git a/interfaces/inner_api/gdb/include/path.h b/interfaces/inner_api/gdb/include/path.h
index d7095e2d70276b1b8e2a7dcfad6650911f212f6a..c2bff7ada736868fe16df2b1d3be7e5c26857fc5 100644
--- a/interfaces/inner_api/gdb/include/path.h
+++ b/interfaces/inner_api/gdb/include/path.h
@@ -23,20 +23,20 @@
 #include <vector>
 
 #include "edge.h"
-#include "nlohmann/json.hpp"
 #include "path_segment.h"
 #include "rdb_visibility.h"
+#include "serializable.h"
 #include "vertex.h"
 
 namespace OHOS::DistributedDataAip {
-class Path {
+class Path  final : public Serializable {
 public:
     API_EXPORT Path();
     API_EXPORT Path(std::shared_ptr<Vertex> start, std::shared_ptr<Vertex> end);
     API_EXPORT Path(std::shared_ptr<Vertex> start, std::shared_ptr<Vertex> end, uint32_t pathLen,
         std::vector<std::shared_ptr<PathSegment>> segments);
 
-    static std::shared_ptr<Path> Parse(const nlohmann::json &json, int32_t &errCode);
+    static std::shared_ptr<Path> Parse(const std::string &jsonStr, int32_t &errCode);
 
     API_EXPORT uint32_t GetPathLength() const;
     API_EXPORT void SetPathLength(uint32_t pathLen);
@@ -46,6 +46,9 @@ public:
     API_EXPORT void SetEnd(std::shared_ptr<Vertex> end);
     API_EXPORT const std::vector<std::shared_ptr<PathSegment>> &GetSegments() const;
 
+    bool Marshal(json &node) const override;
+    bool Unmarshal(const json &node) override;
+
     static constexpr const char *PATHLEN = "length";
     static constexpr const char *START = "start";
     static constexpr const char *END = "end";
diff --git a/interfaces/inner_api/gdb/include/path_segment.h b/interfaces/inner_api/gdb/include/path_segment.h
index 31e00a005b87ea59f300ea88b022e27b5400e3e0..cd9ccb7eb3ffcd0807ad822f9d132d2dd837aee7 100644
--- a/interfaces/inner_api/gdb/include/path_segment.h
+++ b/interfaces/inner_api/gdb/include/path_segment.h
@@ -24,15 +24,16 @@
 
 #include "edge.h"
 #include "rdb_visibility.h"
+#include "serializable.h"
 #include "vertex.h"
 
 namespace OHOS::DistributedDataAip {
-class PathSegment {
+class PathSegment final : public Serializable {
 public:
     API_EXPORT PathSegment();
     API_EXPORT PathSegment(std::shared_ptr<Vertex> sourceVertex, std::shared_ptr<Vertex> targetVertex,
         std::shared_ptr<Edge> edge);
-    static std::shared_ptr<PathSegment> Parse(const nlohmann::json &json, int32_t &errCode);
+    static std::shared_ptr<PathSegment> Parse(const std::string &jsonStr, int32_t &errCode);
 
     API_EXPORT std::shared_ptr<Vertex> GetSourceVertex() const;
     API_EXPORT void SetSourceVertex(std::shared_ptr<Vertex> vertex);
@@ -43,6 +44,9 @@ public:
     API_EXPORT std::shared_ptr<Vertex> GetTargetVertex() const;
     API_EXPORT void SetTargetVertex(std::shared_ptr<Vertex> vertex);
 
+    bool Marshal(json &node) const override;
+    bool Unmarshal(const json &node) override;
+
     static constexpr const char *SOURCE_VERTEX = "start";
     static constexpr const char *TARGET_VERTEX = "end";
     static constexpr const char *EDGE = "relationship";
diff --git a/interfaces/inner_api/gdb/include/vertex.h b/interfaces/inner_api/gdb/include/vertex.h
index c78d38317797ad426d5ee516fa562079f1348845..d5f178d70f6a63dcf5e9babc11efcadb625d8bdd 100644
--- a/interfaces/inner_api/gdb/include/vertex.h
+++ b/interfaces/inner_api/gdb/include/vertex.h
@@ -22,29 +22,34 @@
 #include <variant>
 #include <vector>
 
-#include "nlohmann/json.hpp"
 #include "rdb_visibility.h"
+#include "serializable.h"
 
 namespace OHOS::DistributedDataAip {
 using PropType = std::variant<int64_t, double, std::string, bool, std::nullptr_t>;
-class Vertex {
+class Vertex final : public Serializable {
 public:
     API_EXPORT Vertex();
     API_EXPORT virtual ~Vertex() = default;
     API_EXPORT Vertex(std::string id, std::string label);
     API_EXPORT Vertex(std::string id, std::string label, const std::unordered_map<std::string, PropType> &properties);
-    static std::shared_ptr<Vertex> Parse(const nlohmann::json &json, int32_t &errCode);
+    static std::shared_ptr<Vertex> Parse(const std::string &jsonStr, int32_t &errCode);
 
     API_EXPORT std::string GetId() const;
     API_EXPORT void SetId(std::string id);
 
     API_EXPORT const std::string &GetLabel() const;
-    API_EXPORT const std::vector<std::string> &GetLabels() const;
+    API_EXPORT const std::vector<std::string> &GetLabels();
     API_EXPORT void SetLabel(const std::string &label);
 
     API_EXPORT const std::unordered_map<std::string, PropType> &GetProperties() const;
     API_EXPORT void SetProperty(const std::string &key, PropType value);
 
+    bool Marshal(json &node) const override;
+    bool Unmarshal(const json &node) override;
+    static bool GetPropsValue(const json &node, const std::string &name, std::unordered_map<std::string, PropType> &props);
+    static bool GetID(const json &node, const std::string &name, std::string &id);
+
     static constexpr const char *ID = "identity";
     static constexpr const char *LABEL = "label";
     static constexpr const char *PROPERTIES = "properties";
diff --git a/test/native/appdatafwk/unittest/serializable_test.cpp b/test/native/appdatafwk/unittest/serializable_test.cpp
index 4744e929a51fb690bca4710a513148bb005870ba..4f965a92f5db4c9c9ec93b3e16fab6debc08a546 100644
--- a/test/native/appdatafwk/unittest/serializable_test.cpp
+++ b/test/native/appdatafwk/unittest/serializable_test.cpp
@@ -127,7 +127,7 @@ HWTEST_F(SerializableTest, GetNormalVal, TestSize.Level2)
     normal.value = -56;
     normal.isClear = true;
     normal.cols = { "adfasdfas" };
-    auto jstr = to_string(normal.Marshall());
+    auto jstr = Serializable::JSONWrapper::to_string(normal.Marshall());
     Normal normal1;
     normal1.Unmarshall(jstr);
     ASSERT_TRUE(normal == normal1) << normal1.name;
@@ -156,7 +156,7 @@ HWTEST_F(SerializableTest, GetMutilVal, TestSize.Level2)
     NormalEx normalEx;
     normalEx.normals = { Normal() };
     normalEx.name = "normalEx";
-    auto jstr = to_string(normalEx.Marshall());
+    auto jstr = Serializable::JSONWrapper::to_string(normalEx.Marshall());
     NormalEx normal1;
     normal1.Unmarshall(jstr);
     ASSERT_TRUE(normalEx == normal1) << normal1.name;
diff --git a/test/native/gdb/BUILD.gn b/test/native/gdb/BUILD.gn
index 0ab7b08dd8d467ccf132fd61f7af851d76b50ece..ac7065a4c588a5ff8413f83efe7b2fbed8a96657 100644
--- a/test/native/gdb/BUILD.gn
+++ b/test/native/gdb/BUILD.gn
@@ -67,14 +67,15 @@ ohos_unittest("NativeGdbTest") {
     "unittest/gdb_transaction_test.cpp",
   ]
 
+  deps = [ "${relational_store_innerapi_path}/appdatafwk:relational_common_base" ]
   external_deps = [
+    "cJSON:cjson",
     "c_utils:utils",
     "file_api:securitylabel",
     "googletest:gtest_main",
     "hilog:libhilog",
     "hisysevent:libhisysevent",
     "hitrace:hitrace_meter",
-    "json:nlohmann_json_static",
     "kv_store:distributeddata_inner",
   ]
   if (arkdata_db_core_is_exists) {
@@ -96,8 +97,9 @@ ohos_unittest("NativeGdbAdaptTest") {
 
   sources = base_sources
   sources += [ "unittest/gdb_adapt_test.cpp" ]
-
+  deps = [ "${relational_store_innerapi_path}/appdatafwk:relational_common_base" ]
   external_deps = [
+    "cJSON:cjson",
     "c_utils:utils",
     "file_api:securitylabel",
     "googletest:gmock",
@@ -106,7 +108,6 @@ ohos_unittest("NativeGdbAdaptTest") {
     "hisysevent:libhisysevent",
     "hitrace:hitrace_meter",
     "huks:libhukssdk",
-    "json:nlohmann_json_static",
     "kv_store:distributeddata_inner",
   ]
   if (arkdata_db_core_is_exists) {
@@ -153,8 +154,9 @@ ohos_unittest("NativeGdbGrdAdapterTest") {
     "mock/grd_adapter.cpp",
     "unittest/gdb_grd_adapter_test.cpp",
   ]
-
+  deps = [ "${relational_store_innerapi_path}/appdatafwk:relational_common_base" ]
   external_deps = [
+    "cJSON:cjson",
     "c_utils:utils",
     "file_api:securitylabel",
     "googletest:gmock",
@@ -162,7 +164,6 @@ ohos_unittest("NativeGdbGrdAdapterTest") {
     "hilog:libhilog",
     "hisysevent:libhisysevent",
     "hitrace:hitrace_meter",
-    "json:nlohmann_json_static",
   ]
 
   if (arkdata_db_core_is_exists) {
diff --git a/test/native/gdb/fuzztest/gdbstore_fuzzer/BUILD.gn b/test/native/gdb/fuzztest/gdbstore_fuzzer/BUILD.gn
index 9c284170f2764670eb9e3d6df26a69ea3b70b382..6e93f4a471efdb3dee608eb80b2f6935cb63da7b 100644
--- a/test/native/gdb/fuzztest/gdbstore_fuzzer/BUILD.gn
+++ b/test/native/gdb/fuzztest/gdbstore_fuzzer/BUILD.gn
@@ -39,11 +39,14 @@ ohos_fuzztest("GdbStoreFuzzTest") {
 
   sources = [ "gdbstore_fuzzer.cpp" ]
 
-  deps = [ "${relational_store_innerapi_path}/gdb:native_graphstore" ]
+  deps = [
+    "${relational_store_innerapi_path}/appdatafwk:relational_common_base",
+    "${relational_store_innerapi_path}/gdb:native_graphstore",
+  ]
 
   external_deps = [
+    "cJSON:cjson",
     "hilog:libhilog",
-    "json:nlohmann_json_static",
   ]
 }
 
diff --git a/test/native/gdb/unittest/gdb_execute_test.cpp b/test/native/gdb/unittest/gdb_execute_test.cpp
index 4f681022441d0c980f81bc63bb5eb6e9168d8d8a..10cf2872d0cd18623841a2ead15f2b395b2e459e 100644
--- a/test/native/gdb/unittest/gdb_execute_test.cpp
+++ b/test/native/gdb/unittest/gdb_execute_test.cpp
@@ -1113,53 +1113,44 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_ParseEdge, TestSize.Level1)
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
     // no start, no end
-    nlohmann::json json = nlohmann::json::parse("{\"name\" : \"zhangsan\"}", nullptr, false);
-    ASSERT_FALSE(json.is_discarded());
-    ASSERT_FALSE(json.is_null());
-    Edge::Parse(json, errCode);
+    std::string jsonStr = "{\"name\" : \"zhangsan\"}";
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // no identity
-    std::string jsonStr = "{\"start\" : 1, \"end\" : 2}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    jsonStr = "{\"start\" : 1, \"end\" : 2}";
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // ok
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // start is AA
     jsonStr = "{\"start\" : \"AA\", \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // end is B
     jsonStr = "{\"start\" : 1, \"end\" : \"B\", \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // identity is C
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":\"C\","
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // label is 222
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":222,'identity':3,\"properties\":{\"NAME\":\"myCompany3\","
               "\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // key4 is null
     jsonStr =
         "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":2,"
         "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":4.5,\"SEX\":true,\"key1\":true,\"key2\":[], \"key3\":{}, "
         "\"key4\": null}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
@@ -1168,50 +1159,36 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment, TestSize.Level1)
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
     // NO start and end
-    nlohmann::json json = nlohmann::json::parse("{\"name\" : \"zhangsan\"}", nullptr, false);
-    ASSERT_FALSE(json.is_discarded());
-    ASSERT_FALSE(json.is_null());
-    PathSegment::Parse(json, errCode);
+    std::string jsonStr = "{\"name\" : \"zhangsan\"}";
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
     // no relationship
-    std::string jsonStr = "{\"start\" : {}, \"end\" : {}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    jsonStr = "{\"start\" : {}, \"end\" : {}}";
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
-
     jsonStr = "{\"start\" : {}, \"end\" : {}, \"relationship\":{}, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
-
     jsonStr = "{\"start\" : {}, \"end\" : {}, \"relationship\":{}, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
-
     jsonStr = "{\"start\" : {}, \"end\" : {}, \"relationship\":{}, \"label\":\"COMPANY\",\"identity\":\"C\","
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
-
     jsonStr = "{\"start\" : {}, \"end\" : {}, \"relationship\":{}, \"label\":222,\"identity\":2,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
-
     jsonStr = "{\"start\" : {}, \"end\" : {}, \"relationship\":{}, \"label\":\"COMPANY\",\"identity\":2,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":4.5,\"SEX\":true,\"key1\":true,\"key2\":[], "
               "\"key3\":{}, \"key4\": null}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 
-    json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(pathJsonString, errCode);
     ASSERT_EQ(errCode, E_OK);
 }
 
@@ -1219,8 +1196,7 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment02, TestSize.Level1)
 {
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
-    nlohmann::json json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(pathJsonString, errCode);
     EXPECT_EQ(errCode, E_OK);
     // identity:A, E_OK
     std::string jsonStr =
@@ -1230,8 +1206,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
 
     // label:2, E_PARSE_JSON_FAILED
@@ -1242,8 +1218,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     // relationship->start:B, E_OK
@@ -1254,8 +1230,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":\"B\",\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
 
     // relationship->end:C, E_OK
@@ -1266,8 +1242,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":\"C\",\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_OK);
 }
 
@@ -1275,8 +1251,7 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment03, TestSize.Level1)
 {
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
-    nlohmann::json json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(pathJsonString, errCode);
     ASSERT_EQ(errCode, E_OK);
     // end no label:PERSON and identity: A
     std::string jsonStr =
@@ -1286,41 +1261,40 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment03, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
     
     jsonStr = "{\"start\" : 1, \"end\" : {}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     jsonStr = "{\"start\" : {}, \"relationship\" : 1}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     jsonStr = "{\"start\" : {}, \"relationship\" : {}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     jsonStr = "{\"start\" : {}, \"relationship\" : {}, \"end\" : 1}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     jsonStr = "{\"start\" : {}, \"relationship\" : {}, \"end\" : {}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
 HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment04, TestSize.Level1)
 {
     int errCode = E_ERROR;
-    nlohmann::json json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    PathSegment::Parse(pathJsonString, errCode);
     EXPECT_EQ(errCode, E_OK);
     // identity:A, E_OK
     std::string jsonStr =
@@ -1330,8 +1304,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment04, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     std::shared_ptr<Vertex> sourceVertex;
     std::shared_ptr<Vertex> targetVertex;
@@ -1347,8 +1321,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_PathSegment04, TestSize.Level1)
         "\"end\":{\"label\":\"PERSON\",\"identity\":2,\"properties\":{\"AGE\":28,\"SALARY\":65000,"
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    PathSegment::Parse(json, errCode);
+    
+    PathSegment::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
@@ -1378,8 +1352,7 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path02, TestSize.Level1)
 {
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
-    nlohmann::json json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    Path::Parse(json, errCode);
+    Path::Parse(pathJsonString, errCode);
     // no length
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // identity:A, E_OK
@@ -1396,8 +1369,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":\"C\",\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}]}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Path::Parse(json, errCode);
+    
+    Path::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
 
     // label:2, E_PARSE_JSON_FAILED
@@ -1408,8 +1381,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path02, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}},\"segments\":[{}]}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Path::Parse(json, errCode);
+    
+    Path::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
@@ -1417,8 +1390,7 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path03, TestSize.Level1)
 {
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
-    nlohmann::json json = nlohmann::json::parse(pathJsonString, nullptr, false);
-    Path::Parse(json, errCode);
+    Path::Parse(pathJsonString, errCode);
     // no length
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // relationship->start:B, E_OK
@@ -1429,8 +1401,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path03, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":\"B\",\"end\":2,\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}},\"segments\":[{}]}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Path::Parse(json, errCode);
+    
+    Path::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     // relationship->end:C, E_OK
@@ -1447,8 +1419,8 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Path03, TestSize.Level1)
         "\"NAME\":\"Bob\",\"GENDER\":\"Male\",\"PHONENUMBERS\":\"123456789\",\"EMAILS\":\" bob@example.com\"}},"
         "\"relationship\":{\"label\":\"tttt\",\"identity\":3,\"start\":1,\"end\":\"C\",\"properties\":{\"NUM\":4,"
         "\"PINYIN\":\"zhixiqinshu\"}}}]}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Path::Parse(json, errCode);
+    
+    Path::Parse(jsonStr, errCode);
     ASSERT_EQ(errCode, E_OK);
 }
 
@@ -1457,53 +1429,51 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_Vertex, TestSize.Level1)
     ASSERT_NE(store_, nullptr);
     int errCode = E_ERROR;
     // no start, no end
-    nlohmann::json json = nlohmann::json::parse("{\"name\" : \"zhangsan\"}", nullptr, false);
-    ASSERT_FALSE(json.is_discarded());
-    ASSERT_FALSE(json.is_null());
-    Vertex::Parse(json, errCode);
+    auto jsonStr = "{\"name\" : \"zhangsan\"}";
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // no identity
-    std::string jsonStr = "{\"start\" : 1, \"end\" : 2}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    jsonStr = "{\"start\" : 1, \"end\" : 2}";
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // ok
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // start is AA
     jsonStr = "{\"start\" : \"AA\", \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // end is B
     jsonStr = "{\"start\" : 1, \"end\" : \"B\", \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // identity is C
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":\"C\","
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
     // label is 222
     jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":222,'identity':3,\"properties\":{\"NAME\":\"myCompany3\","
               "\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
     // key4 is null
     jsonStr =
         "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":2,"
         "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":4.5,\"SEX\":true,\"key1\":true,\"key2\":[], \"key3\":{}, "
         "\"key4\": null}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Vertex::Parse(json, errCode);
+    
+    Vertex::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
@@ -1930,20 +1900,19 @@ HWTEST_F(GdbExecuteTest, GdbStore_Execute_EdgeTest, TestSize.Level1)
     
     auto jsonStr = "{\"start\" : 1, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    nlohmann::json json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_OK);
 
     jsonStr = "{\"start\" : {}, \"end\" : 2, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 
     jsonStr = "{\"start\" : 1, \"end\" : {}, \"label\":\"COMPANY\",\"identity\":3,"
               "\"properties\":{\"NAME\":\"myCompany3\",\"FOUNDED\":2011}}";
-    json = nlohmann::json::parse(jsonStr, nullptr, false);
-    Edge::Parse(json, errCode);
+    
+    Edge::Parse(jsonStr, errCode);
     EXPECT_EQ(errCode, E_PARSE_JSON_FAILED);
 }
 
